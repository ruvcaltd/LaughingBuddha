//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IAuthClient {

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: AuthenticationRequest | undefined, signal?: AbortSignal): Promise<AuthenticationResponse>;
}

export class AuthClient implements IAuthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: AuthenticationRequest | undefined, signal?: AbortSignal): Promise<AuthenticationResponse> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<AuthenticationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthenticationResponse>(null as any);
    }
}

export interface ICashflowClient {

    /**
     * @return OK
     */
    daily(asOfDate: Date, signal?: AbortSignal): Promise<FundAccountCashflowsDto[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    cashflowPOST(body: CreateCashflowDto | undefined, signal?: AbortSignal): Promise<CashflowDto>;

    /**
     * @return No Content
     */
    cashflowDELETE(id: number, signal?: AbortSignal): Promise<void>;
}

export class CashflowClient implements ICashflowClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    daily(asOfDate: Date, signal?: AbortSignal): Promise<FundAccountCashflowsDto[]> {
        let url_ = this.baseUrl + "/api/Cashflow/daily/{asOfDate}";
        if (asOfDate === undefined || asOfDate === null)
            throw new globalThis.Error("The parameter 'asOfDate' must be defined.");
        url_ = url_.replace("{asOfDate}", encodeURIComponent(asOfDate ? "" + asOfDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDaily(_response);
        });
    }

    protected processDaily(response: Response): Promise<FundAccountCashflowsDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FundAccountCashflowsDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FundAccountCashflowsDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    cashflowPOST(body: CreateCashflowDto | undefined, signal?: AbortSignal): Promise<CashflowDto> {
        let url_ = this.baseUrl + "/api/Cashflow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCashflowPOST(_response);
        });
    }

    protected processCashflowPOST(response: Response): Promise<CashflowDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CashflowDto.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CashflowDto>(null as any);
    }

    /**
     * @return No Content
     */
    cashflowDELETE(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Cashflow/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCashflowDELETE(_response);
        });
    }

    protected processCashflowDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface ICollateralTypesClient {

    /**
     * @return OK
     */
    collateralTypes(signal?: AbortSignal): Promise<CollateralTypeDto[]>;
}

export class CollateralTypesClient implements ICollateralTypesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    collateralTypes(signal?: AbortSignal): Promise<CollateralTypeDto[]> {
        let url_ = this.baseUrl + "/api/CollateralTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCollateralTypes(_response);
        });
    }

    protected processCollateralTypes(response: Response): Promise<CollateralTypeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CollateralTypeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CollateralTypeDto[]>(null as any);
    }
}

export interface ICounterpartiesClient {

    /**
     * @return OK
     */
    counterparties(signal?: AbortSignal): Promise<CounterpartyDto[]>;
}

export class CounterpartiesClient implements ICounterpartiesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    counterparties(signal?: AbortSignal): Promise<CounterpartyDto[]> {
        let url_ = this.baseUrl + "/api/Counterparties";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCounterparties(_response);
        });
    }

    protected processCounterparties(response: Response): Promise<CounterpartyDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CounterpartyDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterpartyDto[]>(null as any);
    }
}

export interface IFundsClient {

    /**
     * @return OK
     */
    balances(asOfDate: Date, signal?: AbortSignal): Promise<FundBalanceDto[]>;

    /**
     * @return OK
     */
    flatten(asOfDate: Date, signal?: AbortSignal): Promise<void>;
}

export class FundsClient implements IFundsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    balances(asOfDate: Date, signal?: AbortSignal): Promise<FundBalanceDto[]> {
        let url_ = this.baseUrl + "/api/Funds/balances/{asOfDate}";
        if (asOfDate === undefined || asOfDate === null)
            throw new globalThis.Error("The parameter 'asOfDate' must be defined.");
        url_ = url_.replace("{asOfDate}", encodeURIComponent(asOfDate ? "" + asOfDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBalances(_response);
        });
    }

    protected processBalances(response: Response): Promise<FundBalanceDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FundBalanceDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FundBalanceDto[]>(null as any);
    }

    /**
     * @return OK
     */
    flatten(asOfDate: Date, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Funds/flatten/{asOfDate}";
        if (asOfDate === undefined || asOfDate === null)
            throw new globalThis.Error("The parameter 'asOfDate' must be defined.");
        url_ = url_.replace("{asOfDate}", encodeURIComponent(asOfDate ? "" + asOfDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFlatten(_response);
        });
    }

    protected processFlatten(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IPositionsClient {

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: PositionChangeDto | undefined, signal?: AbortSignal): Promise<PositionChangeDto>;

    /**
     * @param date (optional) 
     * @return OK
     */
    day(date: Date | undefined, signal?: AbortSignal): Promise<PositionDto[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    broadcastLock(body: PositionLockDto | undefined, signal?: AbortSignal): Promise<void>;
}

export class PositionsClient implements IPositionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: PositionChangeDto | undefined, signal?: AbortSignal): Promise<PositionChangeDto> {
        let url_ = this.baseUrl + "/api/Positions/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<PositionChangeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PositionChangeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PositionChangeDto>(null as any);
    }

    /**
     * @param date (optional) 
     * @return OK
     */
    day(date: Date | undefined, signal?: AbortSignal): Promise<PositionDto[]> {
        let url_ = this.baseUrl + "/api/Positions/day?";
        if (date === null)
            throw new globalThis.Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDay(_response);
        });
    }

    protected processDay(response: Response): Promise<PositionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PositionDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PositionDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    broadcastLock(body: PositionLockDto | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Positions/broadcast-lock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBroadcastLock(_response);
        });
    }

    protected processBroadcastLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IRepoRatesClient {

    /**
     * @return OK
     */
    date(repoDate: Date, signal?: AbortSignal): Promise<RepoRateDto[]>;

    /**
     * @param currentDate (optional) 
     * @return OK
     */
    previousDay(currentDate: Date | undefined, signal?: AbortSignal): Promise<PreviousDayRepoRateDto[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    newDay(body: Date | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return Created
     */
    repoRatesPOST(body: CreateRepoRateDto | undefined, signal?: AbortSignal): Promise<RepoRateDto>;

    /**
     * @param body (optional) 
     * @return OK
     */
    repoRatesPUT(id: number, body: UpdateRepoRateDto | undefined, signal?: AbortSignal): Promise<boolean>;

    /**
     * @return OK
     */
    setInactive(id: number, signal?: AbortSignal): Promise<RepoRateDto>;

    /**
     * @return OK
     */
    setActive(id: number, signal?: AbortSignal): Promise<RepoRateDto>;
}

export class RepoRatesClient implements IRepoRatesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    date(repoDate: Date, signal?: AbortSignal): Promise<RepoRateDto[]> {
        let url_ = this.baseUrl + "/api/RepoRates/date/{repoDate}";
        if (repoDate === undefined || repoDate === null)
            throw new globalThis.Error("The parameter 'repoDate' must be defined.");
        url_ = url_.replace("{repoDate}", encodeURIComponent(repoDate ? "" + repoDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDate(_response);
        });
    }

    protected processDate(response: Response): Promise<RepoRateDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoRateDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoRateDto[]>(null as any);
    }

    /**
     * @param currentDate (optional) 
     * @return OK
     */
    previousDay(currentDate: Date | undefined, signal?: AbortSignal): Promise<PreviousDayRepoRateDto[]> {
        let url_ = this.baseUrl + "/api/RepoRates/previous-day?";
        if (currentDate === null)
            throw new globalThis.Error("The parameter 'currentDate' cannot be null.");
        else if (currentDate !== undefined)
            url_ += "currentDate=" + encodeURIComponent(currentDate ? "" + currentDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPreviousDay(_response);
        });
    }

    protected processPreviousDay(response: Response): Promise<PreviousDayRepoRateDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PreviousDayRepoRateDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PreviousDayRepoRateDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    newDay(body: Date | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/RepoRates/new-day";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNewDay(_response);
        });
    }

    protected processNewDay(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    repoRatesPOST(body: CreateRepoRateDto | undefined, signal?: AbortSignal): Promise<RepoRateDto> {
        let url_ = this.baseUrl + "/api/RepoRates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepoRatesPOST(_response);
        });
    }

    protected processRepoRatesPOST(response: Response): Promise<RepoRateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = RepoRateDto.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoRateDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    repoRatesPUT(id: number, body: UpdateRepoRateDto | undefined, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/RepoRates/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepoRatesPUT(_response);
        });
    }

    protected processRepoRatesPUT(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return OK
     */
    setInactive(id: number, signal?: AbortSignal): Promise<RepoRateDto> {
        let url_ = this.baseUrl + "/api/RepoRates/{id}/set-inactive";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetInactive(_response);
        });
    }

    protected processSetInactive(response: Response): Promise<RepoRateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoRateDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoRateDto>(null as any);
    }

    /**
     * @return OK
     */
    setActive(id: number, signal?: AbortSignal): Promise<RepoRateDto> {
        let url_ = this.baseUrl + "/api/RepoRates/{id}/set-active";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetActive(_response);
        });
    }

    protected processSetActive(response: Response): Promise<RepoRateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoRateDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoRateDto>(null as any);
    }
}

export interface IRepoTradesClient {

    /**
     * @param fundId (optional) 
     * @param counterpartyId (optional) 
     * @param collateralTypeId (optional) 
     * @param startDateFrom (optional) 
     * @param startDateTo (optional) 
     * @param settlementDate (optional) 
     * @param status (optional) 
     * @param direction (optional) 
     * @return OK
     */
    search(fundId: number | undefined, counterpartyId: number | undefined, collateralTypeId: number | undefined, startDateFrom: Date | undefined, startDateTo: Date | undefined, settlementDate: Date | undefined, status: string | undefined, direction: string | undefined, signal?: AbortSignal): Promise<RepoTradeDto[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    submit(body: number[] | undefined, signal?: AbortSignal): Promise<RepoTradeDto[]>;
}

export class RepoTradesClient implements IRepoTradesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param fundId (optional) 
     * @param counterpartyId (optional) 
     * @param collateralTypeId (optional) 
     * @param startDateFrom (optional) 
     * @param startDateTo (optional) 
     * @param settlementDate (optional) 
     * @param status (optional) 
     * @param direction (optional) 
     * @return OK
     */
    search(fundId: number | undefined, counterpartyId: number | undefined, collateralTypeId: number | undefined, startDateFrom: Date | undefined, startDateTo: Date | undefined, settlementDate: Date | undefined, status: string | undefined, direction: string | undefined, signal?: AbortSignal): Promise<RepoTradeDto[]> {
        let url_ = this.baseUrl + "/api/RepoTrades/search?";
        if (fundId === null)
            throw new globalThis.Error("The parameter 'fundId' cannot be null.");
        else if (fundId !== undefined)
            url_ += "FundId=" + encodeURIComponent("" + fundId) + "&";
        if (counterpartyId === null)
            throw new globalThis.Error("The parameter 'counterpartyId' cannot be null.");
        else if (counterpartyId !== undefined)
            url_ += "CounterpartyId=" + encodeURIComponent("" + counterpartyId) + "&";
        if (collateralTypeId === null)
            throw new globalThis.Error("The parameter 'collateralTypeId' cannot be null.");
        else if (collateralTypeId !== undefined)
            url_ += "CollateralTypeId=" + encodeURIComponent("" + collateralTypeId) + "&";
        if (startDateFrom === null)
            throw new globalThis.Error("The parameter 'startDateFrom' cannot be null.");
        else if (startDateFrom !== undefined)
            url_ += "StartDateFrom=" + encodeURIComponent(startDateFrom ? "" + startDateFrom.toISOString() : "") + "&";
        if (startDateTo === null)
            throw new globalThis.Error("The parameter 'startDateTo' cannot be null.");
        else if (startDateTo !== undefined)
            url_ += "StartDateTo=" + encodeURIComponent(startDateTo ? "" + startDateTo.toISOString() : "") + "&";
        if (settlementDate === null)
            throw new globalThis.Error("The parameter 'settlementDate' cannot be null.");
        else if (settlementDate !== undefined)
            url_ += "SettlementDate=" + encodeURIComponent(settlementDate ? "" + settlementDate.toISOString() : "") + "&";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (direction === null)
            throw new globalThis.Error("The parameter 'direction' cannot be null.");
        else if (direction !== undefined)
            url_ += "Direction=" + encodeURIComponent("" + direction) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<RepoTradeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoTradeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoTradeDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    submit(body: number[] | undefined, signal?: AbortSignal): Promise<RepoTradeDto[]> {
        let url_ = this.baseUrl + "/api/RepoTrades/submit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubmit(_response);
        });
    }

    protected processSubmit(response: Response): Promise<RepoTradeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoTradeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoTradeDto[]>(null as any);
    }
}

export interface ISecuritiesClient {

    /**
     * @return OK
     */
    securitiesAll(signal?: AbortSignal): Promise<SecurityDto[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    securitiesPOST(body: CreateSecurityDto | undefined, signal?: AbortSignal): Promise<SecurityDto>;

    /**
     * @return OK
     */
    securitiesGET(id: number, signal?: AbortSignal): Promise<SecurityDto>;

    /**
     * @param body (optional) 
     * @return OK
     */
    securitiesPUT(id: number, body: UpdateSecurityDto | undefined, signal?: AbortSignal): Promise<SecurityDto>;

    /**
     * @return OK
     */
    securitiesDELETE(id: number, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    isin(isin: string, signal?: AbortSignal): Promise<SecurityDto>;

    /**
     * @return OK
     */
    type(assetType: string, signal?: AbortSignal): Promise<SecurityDto[]>;
}

export class SecuritiesClient implements ISecuritiesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    securitiesAll(signal?: AbortSignal): Promise<SecurityDto[]> {
        let url_ = this.baseUrl + "/api/Securities";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSecuritiesAll(_response);
        });
    }

    protected processSecuritiesAll(response: Response): Promise<SecurityDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SecurityDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    securitiesPOST(body: CreateSecurityDto | undefined, signal?: AbortSignal): Promise<SecurityDto> {
        let url_ = this.baseUrl + "/api/Securities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSecuritiesPOST(_response);
        });
    }

    protected processSecuritiesPOST(response: Response): Promise<SecurityDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityDto>(null as any);
    }

    /**
     * @return OK
     */
    securitiesGET(id: number, signal?: AbortSignal): Promise<SecurityDto> {
        let url_ = this.baseUrl + "/api/Securities/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSecuritiesGET(_response);
        });
    }

    protected processSecuritiesGET(response: Response): Promise<SecurityDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    securitiesPUT(id: number, body: UpdateSecurityDto | undefined, signal?: AbortSignal): Promise<SecurityDto> {
        let url_ = this.baseUrl + "/api/Securities/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSecuritiesPUT(_response);
        });
    }

    protected processSecuritiesPUT(response: Response): Promise<SecurityDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityDto>(null as any);
    }

    /**
     * @return OK
     */
    securitiesDELETE(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Securities/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSecuritiesDELETE(_response);
        });
    }

    protected processSecuritiesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    isin(isin: string, signal?: AbortSignal): Promise<SecurityDto> {
        let url_ = this.baseUrl + "/api/Securities/isin/{isin}";
        if (isin === undefined || isin === null)
            throw new globalThis.Error("The parameter 'isin' must be defined.");
        url_ = url_.replace("{isin}", encodeURIComponent("" + isin));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsin(_response);
        });
    }

    protected processIsin(response: Response): Promise<SecurityDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityDto>(null as any);
    }

    /**
     * @return OK
     */
    type(assetType: string, signal?: AbortSignal): Promise<SecurityDto[]> {
        let url_ = this.baseUrl + "/api/Securities/type/{assetType}";
        if (assetType === undefined || assetType === null)
            throw new globalThis.Error("The parameter 'assetType' must be defined.");
        url_ = url_.replace("{assetType}", encodeURIComponent("" + assetType));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processType(_response);
        });
    }

    protected processType(response: Response): Promise<SecurityDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SecurityDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityDto[]>(null as any);
    }
}

export class AccountCashflowsDto implements IAccountCashflowsDto {
    cashAccountId?: number;
    accountName?: string | undefined;
    currencyCode?: string | undefined;
    cashflows?: CashflowDto[] | undefined;

    constructor(data?: IAccountCashflowsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cashAccountId = _data["cashAccountId"];
            this.accountName = _data["accountName"];
            this.currencyCode = _data["currencyCode"];
            if (Array.isArray(_data["cashflows"])) {
                this.cashflows = [] as any;
                for (let item of _data["cashflows"])
                    this.cashflows!.push(CashflowDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountCashflowsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountCashflowsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashAccountId"] = this.cashAccountId;
        data["accountName"] = this.accountName;
        data["currencyCode"] = this.currencyCode;
        if (Array.isArray(this.cashflows)) {
            data["cashflows"] = [];
            for (let item of this.cashflows)
                data["cashflows"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IAccountCashflowsDto {
    cashAccountId?: number;
    accountName?: string | undefined;
    currencyCode?: string | undefined;
    cashflows?: CashflowDto[] | undefined;
}

export class AuthenticationRequest implements IAuthenticationRequest {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: IAuthenticationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IAuthenticationRequest {
    email?: string | undefined;
    password?: string | undefined;
}

export class AuthenticationResponse implements IAuthenticationResponse {
    userId?: number;
    token?: string | undefined;
    email?: string | undefined;
    displayName?: string | undefined;

    constructor(data?: IAuthenticationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.token = _data["token"];
            this.email = _data["email"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AuthenticationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["token"] = this.token;
        data["email"] = this.email;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAuthenticationResponse {
    userId?: number;
    token?: string | undefined;
    email?: string | undefined;
    displayName?: string | undefined;
}

export class CashflowDto implements ICashflowDto {
    id?: number;
    cashAccountId?: number;
    accountNumber?: string | undefined;
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    repoTradeId?: number | undefined;
    tradeReference?: string | undefined;
    amount?: number;
    currencyCode?: string | undefined;
    effectiveDate?: Date;
    description?: string | undefined;
    source?: string | undefined;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: ICashflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cashAccountId = _data["cashAccountId"];
            this.accountNumber = _data["accountNumber"];
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.repoTradeId = _data["repoTradeId"];
            this.tradeReference = _data["tradeReference"];
            this.amount = _data["amount"];
            this.currencyCode = _data["currencyCode"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : undefined as any;
            this.description = _data["description"];
            this.source = _data["source"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): CashflowDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cashAccountId"] = this.cashAccountId;
        data["accountNumber"] = this.accountNumber;
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["repoTradeId"] = this.repoTradeId;
        data["tradeReference"] = this.tradeReference;
        data["amount"] = this.amount;
        data["currencyCode"] = this.currencyCode;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : undefined as any;
        data["description"] = this.description;
        data["source"] = this.source;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface ICashflowDto {
    id?: number;
    cashAccountId?: number;
    accountNumber?: string | undefined;
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    repoTradeId?: number | undefined;
    tradeReference?: string | undefined;
    amount?: number;
    currencyCode?: string | undefined;
    effectiveDate?: Date;
    description?: string | undefined;
    source?: string | undefined;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class CollateralTypeDto implements ICollateralTypeDto {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    standardHaircut?: number | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: ICollateralTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.standardHaircut = _data["standardHaircut"];
            this.isActive = _data["isActive"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): CollateralTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollateralTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["standardHaircut"] = this.standardHaircut;
        data["isActive"] = this.isActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface ICollateralTypeDto {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    standardHaircut?: number | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class CounterpartyDto implements ICounterpartyDto {
    id?: number;
    name?: string | undefined;
    shortName?: string | undefined;
    country?: string | undefined;
    creditRating?: string | undefined;
    sector?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: ICounterpartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            this.country = _data["country"];
            this.creditRating = _data["creditRating"];
            this.sector = _data["sector"];
            this.isActive = _data["isActive"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): CounterpartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["country"] = this.country;
        data["creditRating"] = this.creditRating;
        data["sector"] = this.sector;
        data["isActive"] = this.isActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface ICounterpartyDto {
    id?: number;
    name?: string | undefined;
    shortName?: string | undefined;
    country?: string | undefined;
    creditRating?: string | undefined;
    sector?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class CreateCashflowDto implements ICreateCashflowDto {
    cashAccountId?: number;
    fundId?: number;
    repoTradeId?: number | undefined;
    amount?: number;
    currencyCode?: string | undefined;
    cashflowDate?: Date;
    description?: string | undefined;
    source?: string | undefined;
    createdByUserId?: number;

    constructor(data?: ICreateCashflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cashAccountId = _data["cashAccountId"];
            this.fundId = _data["fundId"];
            this.repoTradeId = _data["repoTradeId"];
            this.amount = _data["amount"];
            this.currencyCode = _data["currencyCode"];
            this.cashflowDate = _data["cashflowDate"] ? new Date(_data["cashflowDate"].toString()) : undefined as any;
            this.description = _data["description"];
            this.source = _data["source"];
            this.createdByUserId = _data["createdByUserId"];
        }
    }

    static fromJS(data: any): CreateCashflowDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCashflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashAccountId"] = this.cashAccountId;
        data["fundId"] = this.fundId;
        data["repoTradeId"] = this.repoTradeId;
        data["amount"] = this.amount;
        data["currencyCode"] = this.currencyCode;
        data["cashflowDate"] = this.cashflowDate ? this.cashflowDate.toISOString() : undefined as any;
        data["description"] = this.description;
        data["source"] = this.source;
        data["createdByUserId"] = this.createdByUserId;
        return data;
    }
}

export interface ICreateCashflowDto {
    cashAccountId?: number;
    fundId?: number;
    repoTradeId?: number | undefined;
    amount?: number;
    currencyCode?: string | undefined;
    cashflowDate?: Date;
    description?: string | undefined;
    source?: string | undefined;
    createdByUserId?: number;
}

export class CreateRepoRateDto implements ICreateRepoRateDto {
    counterpartyId?: number;
    collateralTypeId?: number;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean;
    createdByUserId?: number;

    constructor(data?: ICreateRepoRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.counterpartyId = _data["counterpartyId"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.repoDate = _data["repoDate"] ? new Date(_data["repoDate"].toString()) : undefined as any;
            this.repoRate = _data["repoRate"];
            this.targetCircle = _data["targetCircle"];
            this.finalCircle = _data["finalCircle"];
            this.active = _data["active"];
            this.createdByUserId = _data["createdByUserId"];
        }
    }

    static fromJS(data: any): CreateRepoRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRepoRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counterpartyId"] = this.counterpartyId;
        data["collateralTypeId"] = this.collateralTypeId;
        data["repoDate"] = this.repoDate ? this.repoDate.toISOString() : undefined as any;
        data["repoRate"] = this.repoRate;
        data["targetCircle"] = this.targetCircle;
        data["finalCircle"] = this.finalCircle;
        data["active"] = this.active;
        data["createdByUserId"] = this.createdByUserId;
        return data;
    }
}

export interface ICreateRepoRateDto {
    counterpartyId?: number;
    collateralTypeId?: number;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean;
    createdByUserId?: number;
}

export class CreateSecurityDto implements ICreateSecurityDto {
    isin?: string | undefined;
    description?: string | undefined;
    name?: string | undefined;
    assetType?: string | undefined;
    issuer?: string | undefined;
    currency?: string | undefined;
    maturityDate?: Date | undefined;
    createdByUserId?: number;

    constructor(data?: ICreateSecurityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isin = _data["isin"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.assetType = _data["assetType"];
            this.issuer = _data["issuer"];
            this.currency = _data["currency"];
            this.maturityDate = _data["maturityDate"] ? new Date(_data["maturityDate"].toString()) : undefined as any;
            this.createdByUserId = _data["createdByUserId"];
        }
    }

    static fromJS(data: any): CreateSecurityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSecurityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isin"] = this.isin;
        data["description"] = this.description;
        data["name"] = this.name;
        data["assetType"] = this.assetType;
        data["issuer"] = this.issuer;
        data["currency"] = this.currency;
        data["maturityDate"] = this.maturityDate ? this.maturityDate.toISOString() : undefined as any;
        data["createdByUserId"] = this.createdByUserId;
        return data;
    }
}

export interface ICreateSecurityDto {
    isin?: string | undefined;
    description?: string | undefined;
    name?: string | undefined;
    assetType?: string | undefined;
    issuer?: string | undefined;
    currency?: string | undefined;
    maturityDate?: Date | undefined;
    createdByUserId?: number;
}

export class FundAccountCashflowsDto implements IFundAccountCashflowsDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    accounts?: AccountCashflowsDto[] | undefined;

    constructor(data?: IFundAccountCashflowsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            if (Array.isArray(_data["accounts"])) {
                this.accounts = [] as any;
                for (let item of _data["accounts"])
                    this.accounts!.push(AccountCashflowsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FundAccountCashflowsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FundAccountCashflowsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        if (Array.isArray(this.accounts)) {
            data["accounts"] = [];
            for (let item of this.accounts)
                data["accounts"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IFundAccountCashflowsDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    accounts?: AccountCashflowsDto[] | undefined;
}

export class FundBalanceDto implements IFundBalanceDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    availableCash?: number;
    openingBalance?: number | undefined;
    asOfDate?: Date;

    constructor(data?: IFundBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.currencyCode = _data["currencyCode"];
            this.availableCash = _data["availableCash"];
            this.openingBalance = _data["openingBalance"];
            this.asOfDate = _data["asOfDate"] ? new Date(_data["asOfDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): FundBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new FundBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["currencyCode"] = this.currencyCode;
        data["availableCash"] = this.availableCash;
        data["openingBalance"] = this.openingBalance;
        data["asOfDate"] = this.asOfDate ? this.asOfDate.toISOString() : undefined as any;
        return data;
    }
}

export interface IFundBalanceDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    availableCash?: number;
    openingBalance?: number | undefined;
    asOfDate?: Date;
}

export class PositionChangeDto implements IPositionChangeDto {
    collateralTypeId?: number;
    counterpartyId?: number;
    securityId?: number;
    securityMaturityDate?: Date;
    fundId?: number;
    newNotionalAmount?: number;
    newVariance?: number;
    status?: string | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IPositionChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collateralTypeId = _data["collateralTypeId"];
            this.counterpartyId = _data["counterpartyId"];
            this.securityId = _data["securityId"];
            this.securityMaturityDate = _data["securityMaturityDate"] ? new Date(_data["securityMaturityDate"].toString()) : undefined as any;
            this.fundId = _data["fundId"];
            this.newNotionalAmount = _data["newNotionalAmount"];
            this.newVariance = _data["newVariance"];
            this.status = _data["status"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): PositionChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PositionChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collateralTypeId"] = this.collateralTypeId;
        data["counterpartyId"] = this.counterpartyId;
        data["securityId"] = this.securityId;
        data["securityMaturityDate"] = this.securityMaturityDate ? this.securityMaturityDate.toISOString() : undefined as any;
        data["fundId"] = this.fundId;
        data["newNotionalAmount"] = this.newNotionalAmount;
        data["newVariance"] = this.newVariance;
        data["status"] = this.status;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IPositionChangeDto {
    collateralTypeId?: number;
    counterpartyId?: number;
    securityId?: number;
    securityMaturityDate?: Date;
    fundId?: number;
    newNotionalAmount?: number;
    newVariance?: number;
    status?: string | undefined;
    errorMessage?: string | undefined;
}

export class PositionDto implements IPositionDto {
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    securityId?: number;
    variance?: number;
    rate?: number;
    securityName?: string | undefined;
    securityMaturityDate?: Date;
    fundNotionals?: { [key: string]: number; } | undefined;
    exposurePercentages?: { [key: string]: number; } | undefined;
    statuses?: { [key: string]: string; } | undefined;
    commitStatus?: { [key: string]: string; } | undefined;

    constructor(data?: IPositionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collateralTypeId = _data["collateralTypeId"];
            this.collateralTypeName = _data["collateralTypeName"];
            this.counterpartyId = _data["counterpartyId"];
            this.counterpartyName = _data["counterpartyName"];
            this.securityId = _data["securityId"];
            this.variance = _data["variance"];
            this.rate = _data["rate"];
            this.securityName = _data["securityName"];
            this.securityMaturityDate = _data["securityMaturityDate"] ? new Date(_data["securityMaturityDate"].toString()) : undefined as any;
            if (_data["fundNotionals"]) {
                this.fundNotionals = {} as any;
                for (let key in _data["fundNotionals"]) {
                    if (_data["fundNotionals"].hasOwnProperty(key))
                        (this.fundNotionals as any)![key] = _data["fundNotionals"][key];
                }
            }
            if (_data["exposurePercentages"]) {
                this.exposurePercentages = {} as any;
                for (let key in _data["exposurePercentages"]) {
                    if (_data["exposurePercentages"].hasOwnProperty(key))
                        (this.exposurePercentages as any)![key] = _data["exposurePercentages"][key];
                }
            }
            if (_data["statuses"]) {
                this.statuses = {} as any;
                for (let key in _data["statuses"]) {
                    if (_data["statuses"].hasOwnProperty(key))
                        (this.statuses as any)![key] = _data["statuses"][key];
                }
            }
            if (_data["commitStatus"]) {
                this.commitStatus = {} as any;
                for (let key in _data["commitStatus"]) {
                    if (_data["commitStatus"].hasOwnProperty(key))
                        (this.commitStatus as any)![key] = _data["commitStatus"][key];
                }
            }
        }
    }

    static fromJS(data: any): PositionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PositionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collateralTypeId"] = this.collateralTypeId;
        data["collateralTypeName"] = this.collateralTypeName;
        data["counterpartyId"] = this.counterpartyId;
        data["counterpartyName"] = this.counterpartyName;
        data["securityId"] = this.securityId;
        data["variance"] = this.variance;
        data["rate"] = this.rate;
        data["securityName"] = this.securityName;
        data["securityMaturityDate"] = this.securityMaturityDate ? this.securityMaturityDate.toISOString() : undefined as any;
        if (this.fundNotionals) {
            data["fundNotionals"] = {};
            for (let key in this.fundNotionals) {
                if (this.fundNotionals.hasOwnProperty(key))
                    (data["fundNotionals"] as any)[key] = (this.fundNotionals as any)[key];
            }
        }
        if (this.exposurePercentages) {
            data["exposurePercentages"] = {};
            for (let key in this.exposurePercentages) {
                if (this.exposurePercentages.hasOwnProperty(key))
                    (data["exposurePercentages"] as any)[key] = (this.exposurePercentages as any)[key];
            }
        }
        if (this.statuses) {
            data["statuses"] = {};
            for (let key in this.statuses) {
                if (this.statuses.hasOwnProperty(key))
                    (data["statuses"] as any)[key] = (this.statuses as any)[key];
            }
        }
        if (this.commitStatus) {
            data["commitStatus"] = {};
            for (let key in this.commitStatus) {
                if (this.commitStatus.hasOwnProperty(key))
                    (data["commitStatus"] as any)[key] = (this.commitStatus as any)[key];
            }
        }
        return data;
    }
}

export interface IPositionDto {
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    securityId?: number;
    variance?: number;
    rate?: number;
    securityName?: string | undefined;
    securityMaturityDate?: Date;
    fundNotionals?: { [key: string]: number; } | undefined;
    exposurePercentages?: { [key: string]: number; } | undefined;
    statuses?: { [key: string]: string; } | undefined;
    commitStatus?: { [key: string]: string; } | undefined;
}

export class PositionLockDto implements IPositionLockDto {
    counterpartyId?: number;
    collateralTypeId?: number;
    fundId?: number;
    locked?: boolean;
    userDisplay?: string | undefined;

    constructor(data?: IPositionLockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.counterpartyId = _data["counterpartyId"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.fundId = _data["fundId"];
            this.locked = _data["locked"];
            this.userDisplay = _data["userDisplay"];
        }
    }

    static fromJS(data: any): PositionLockDto {
        data = typeof data === 'object' ? data : {};
        let result = new PositionLockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counterpartyId"] = this.counterpartyId;
        data["collateralTypeId"] = this.collateralTypeId;
        data["fundId"] = this.fundId;
        data["locked"] = this.locked;
        data["userDisplay"] = this.userDisplay;
        return data;
    }
}

export interface IPositionLockDto {
    counterpartyId?: number;
    collateralTypeId?: number;
    fundId?: number;
    locked?: boolean;
    userDisplay?: string | undefined;
}

export class PreviousDayRepoRateDto implements IPreviousDayRepoRateDto {
    id?: number;
    counterpartyId?: number;
    collateralTypeId?: number;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number;
    active?: boolean;

    constructor(data?: IPreviousDayRepoRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.counterpartyId = _data["counterpartyId"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.repoDate = _data["repoDate"] ? new Date(_data["repoDate"].toString()) : undefined as any;
            this.repoRate = _data["repoRate"];
            this.targetCircle = _data["targetCircle"];
            this.finalCircle = _data["finalCircle"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): PreviousDayRepoRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PreviousDayRepoRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["counterpartyId"] = this.counterpartyId;
        data["collateralTypeId"] = this.collateralTypeId;
        data["repoDate"] = this.repoDate ? this.repoDate.toISOString() : undefined as any;
        data["repoRate"] = this.repoRate;
        data["targetCircle"] = this.targetCircle;
        data["finalCircle"] = this.finalCircle;
        data["active"] = this.active;
        return data;
    }
}

export interface IPreviousDayRepoRateDto {
    id?: number;
    counterpartyId?: number;
    collateralTypeId?: number;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number;
    active?: boolean;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class RepoRateDto implements IRepoRateDto {
    id?: number;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: IRepoRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.counterpartyId = _data["counterpartyId"];
            this.counterpartyName = _data["counterpartyName"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.collateralTypeName = _data["collateralTypeName"];
            this.repoDate = _data["repoDate"] ? new Date(_data["repoDate"].toString()) : undefined as any;
            this.repoRate = _data["repoRate"];
            this.targetCircle = _data["targetCircle"];
            this.finalCircle = _data["finalCircle"];
            this.active = _data["active"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): RepoRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepoRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["counterpartyId"] = this.counterpartyId;
        data["counterpartyName"] = this.counterpartyName;
        data["collateralTypeId"] = this.collateralTypeId;
        data["collateralTypeName"] = this.collateralTypeName;
        data["repoDate"] = this.repoDate ? this.repoDate.toISOString() : undefined as any;
        data["repoRate"] = this.repoRate;
        data["targetCircle"] = this.targetCircle;
        data["finalCircle"] = this.finalCircle;
        data["active"] = this.active;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface IRepoRateDto {
    id?: number;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class RepoTradeDto implements IRepoTradeDto {
    id?: number;
    tradeReference?: string | undefined;
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    securityId?: number;
    securityIsin?: string | undefined;
    securityName?: string | undefined;
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    direction?: string | undefined;
    notional?: number;
    rate?: number;
    startDate?: Date;
    endDate?: Date;
    settlementDate?: Date;
    status?: string | undefined;
    currency?: string | undefined;
    haircut?: number | undefined;
    collateralValue?: number | undefined;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
    security?: SecurityDto;

    constructor(data?: IRepoTradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tradeReference = _data["tradeReference"];
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.counterpartyId = _data["counterpartyId"];
            this.counterpartyName = _data["counterpartyName"];
            this.securityId = _data["securityId"];
            this.securityIsin = _data["securityIsin"];
            this.securityName = _data["securityName"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.collateralTypeName = _data["collateralTypeName"];
            this.direction = _data["direction"];
            this.notional = _data["notional"];
            this.rate = _data["rate"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : undefined as any;
            this.settlementDate = _data["settlementDate"] ? new Date(_data["settlementDate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.currency = _data["currency"];
            this.haircut = _data["haircut"];
            this.collateralValue = _data["collateralValue"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
            this.security = _data["security"] ? SecurityDto.fromJS(_data["security"]) : undefined as any;
        }
    }

    static fromJS(data: any): RepoTradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepoTradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tradeReference"] = this.tradeReference;
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["counterpartyId"] = this.counterpartyId;
        data["counterpartyName"] = this.counterpartyName;
        data["securityId"] = this.securityId;
        data["securityIsin"] = this.securityIsin;
        data["securityName"] = this.securityName;
        data["collateralTypeId"] = this.collateralTypeId;
        data["collateralTypeName"] = this.collateralTypeName;
        data["direction"] = this.direction;
        data["notional"] = this.notional;
        data["rate"] = this.rate;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : undefined as any;
        data["settlementDate"] = this.settlementDate ? this.settlementDate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["currency"] = this.currency;
        data["haircut"] = this.haircut;
        data["collateralValue"] = this.collateralValue;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        data["security"] = this.security ? this.security.toJSON() : undefined as any;
        return data;
    }
}

export interface IRepoTradeDto {
    id?: number;
    tradeReference?: string | undefined;
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    securityId?: number;
    securityIsin?: string | undefined;
    securityName?: string | undefined;
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    direction?: string | undefined;
    notional?: number;
    rate?: number;
    startDate?: Date;
    endDate?: Date;
    settlementDate?: Date;
    status?: string | undefined;
    currency?: string | undefined;
    haircut?: number | undefined;
    collateralValue?: number | undefined;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
    security?: SecurityDto;
}

export class SecurityDto implements ISecurityDto {
    id?: number;
    isin?: string | undefined;
    description?: string | undefined;
    assetType?: string | undefined;
    issuer?: string | undefined;
    currency?: string | undefined;
    maturityDate?: Date | undefined;
    createdByUserId?: number;
    createdDate?: Date;
    modifiedByUserId?: number | undefined;
    modifiedDate?: Date | undefined;

    constructor(data?: ISecurityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isin = _data["isin"];
            this.description = _data["description"];
            this.assetType = _data["assetType"];
            this.issuer = _data["issuer"];
            this.currency = _data["currency"];
            this.maturityDate = _data["maturityDate"] ? new Date(_data["maturityDate"].toString()) : undefined as any;
            this.createdByUserId = _data["createdByUserId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.modifiedByUserId = _data["modifiedByUserId"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): SecurityDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isin"] = this.isin;
        data["description"] = this.description;
        data["assetType"] = this.assetType;
        data["issuer"] = this.issuer;
        data["currency"] = this.currency;
        data["maturityDate"] = this.maturityDate ? this.maturityDate.toISOString() : undefined as any;
        data["createdByUserId"] = this.createdByUserId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["modifiedByUserId"] = this.modifiedByUserId;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        return data;
    }
}

export interface ISecurityDto {
    id?: number;
    isin?: string | undefined;
    description?: string | undefined;
    assetType?: string | undefined;
    issuer?: string | undefined;
    currency?: string | undefined;
    maturityDate?: Date | undefined;
    createdByUserId?: number;
    createdDate?: Date;
    modifiedByUserId?: number | undefined;
    modifiedDate?: Date | undefined;
}

export class UpdateRepoRateDto implements IUpdateRepoRateDto {
    id?: number;
    counterpartyId?: number;
    collateralTypeId?: number;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean | undefined;
    modifiedByUserId?: number;

    constructor(data?: IUpdateRepoRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.counterpartyId = _data["counterpartyId"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.repoRate = _data["repoRate"];
            this.targetCircle = _data["targetCircle"];
            this.finalCircle = _data["finalCircle"];
            this.active = _data["active"];
            this.modifiedByUserId = _data["modifiedByUserId"];
        }
    }

    static fromJS(data: any): UpdateRepoRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRepoRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["counterpartyId"] = this.counterpartyId;
        data["collateralTypeId"] = this.collateralTypeId;
        data["repoRate"] = this.repoRate;
        data["targetCircle"] = this.targetCircle;
        data["finalCircle"] = this.finalCircle;
        data["active"] = this.active;
        data["modifiedByUserId"] = this.modifiedByUserId;
        return data;
    }
}

export interface IUpdateRepoRateDto {
    id?: number;
    counterpartyId?: number;
    collateralTypeId?: number;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean | undefined;
    modifiedByUserId?: number;
}

export class UpdateSecurityDto implements IUpdateSecurityDto {
    id?: number;
    description?: string | undefined;
    assetType?: string | undefined;
    issuer?: string | undefined;
    currency?: string | undefined;
    maturityDate?: Date | undefined;
    isActive?: boolean;
    modifiedByUserId?: number;

    constructor(data?: IUpdateSecurityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.assetType = _data["assetType"];
            this.issuer = _data["issuer"];
            this.currency = _data["currency"];
            this.maturityDate = _data["maturityDate"] ? new Date(_data["maturityDate"].toString()) : undefined as any;
            this.isActive = _data["isActive"];
            this.modifiedByUserId = _data["modifiedByUserId"];
        }
    }

    static fromJS(data: any): UpdateSecurityDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSecurityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["assetType"] = this.assetType;
        data["issuer"] = this.issuer;
        data["currency"] = this.currency;
        data["maturityDate"] = this.maturityDate ? this.maturityDate.toISOString() : undefined as any;
        data["isActive"] = this.isActive;
        data["modifiedByUserId"] = this.modifiedByUserId;
        return data;
    }
}

export interface IUpdateSecurityDto {
    id?: number;
    description?: string | undefined;
    assetType?: string | undefined;
    issuer?: string | undefined;
    currency?: string | undefined;
    maturityDate?: Date | undefined;
    isActive?: boolean;
    modifiedByUserId?: number;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}