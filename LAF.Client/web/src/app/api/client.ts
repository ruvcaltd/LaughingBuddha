//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAuthClient {
    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: AuthenticationRequest | undefined): Observable<AuthenticationResponse>;
}

@Injectable()
export class AuthClient implements IAuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: AuthenticationRequest | undefined): Observable<AuthenticationResponse> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticationResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticationResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthenticationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICashflowClient {
    /**
     * @return OK
     */
    daily(asOfDate: Date): Observable<FundAccountCashflowsDto[]>;
    /**
     * @param body (optional) 
     * @return Created
     */
    cashflowPOST(body: CreateCashflowDto | undefined): Observable<CashflowDto>;
    /**
     * @return No Content
     */
    cashflowDELETE(id: number): Observable<void>;
}

@Injectable()
export class CashflowClient implements ICashflowClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    daily(asOfDate: Date): Observable<FundAccountCashflowsDto[]> {
        let url_ = this.baseUrl + "/api/Cashflow/daily/{asOfDate}";
        if (asOfDate === undefined || asOfDate === null)
            throw new globalThis.Error("The parameter 'asOfDate' must be defined.");
        url_ = url_.replace("{asOfDate}", encodeURIComponent(asOfDate ? "" + asOfDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDaily(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDaily(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FundAccountCashflowsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FundAccountCashflowsDto[]>;
        }));
    }

    protected processDaily(response: HttpResponseBase): Observable<FundAccountCashflowsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FundAccountCashflowsDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    cashflowPOST(body: CreateCashflowDto | undefined): Observable<CashflowDto> {
        let url_ = this.baseUrl + "/api/Cashflow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCashflowPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCashflowPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CashflowDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CashflowDto>;
        }));
    }

    protected processCashflowPOST(response: HttpResponseBase): Observable<CashflowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CashflowDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    cashflowDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Cashflow/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCashflowDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCashflowDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCashflowDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICollateralTypesClient {
    /**
     * @return OK
     */
    collateralTypes(): Observable<CollateralTypeDto[]>;
}

@Injectable()
export class CollateralTypesClient implements ICollateralTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    collateralTypes(): Observable<CollateralTypeDto[]> {
        let url_ = this.baseUrl + "/api/CollateralTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCollateralTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCollateralTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CollateralTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CollateralTypeDto[]>;
        }));
    }

    protected processCollateralTypes(response: HttpResponseBase): Observable<CollateralTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CollateralTypeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICounterpartiesClient {
    /**
     * @return OK
     */
    counterparties(): Observable<CounterpartyDto[]>;
}

@Injectable()
export class CounterpartiesClient implements ICounterpartiesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    counterparties(): Observable<CounterpartyDto[]> {
        let url_ = this.baseUrl + "/api/Counterparties";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCounterparties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCounterparties(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CounterpartyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CounterpartyDto[]>;
        }));
    }

    protected processCounterparties(response: HttpResponseBase): Observable<CounterpartyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CounterpartyDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFundsClient {
    /**
     * @return OK
     */
    balances(asOfDate: Date): Observable<FundBalanceDto[]>;
    /**
     * @return OK
     */
    flatten(asOfDate: Date): Observable<void>;
}

@Injectable()
export class FundsClient implements IFundsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    balances(asOfDate: Date): Observable<FundBalanceDto[]> {
        let url_ = this.baseUrl + "/api/Funds/balances/{asOfDate}";
        if (asOfDate === undefined || asOfDate === null)
            throw new globalThis.Error("The parameter 'asOfDate' must be defined.");
        url_ = url_.replace("{asOfDate}", encodeURIComponent(asOfDate ? "" + asOfDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalances(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FundBalanceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FundBalanceDto[]>;
        }));
    }

    protected processBalances(response: HttpResponseBase): Observable<FundBalanceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FundBalanceDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    flatten(asOfDate: Date): Observable<void> {
        let url_ = this.baseUrl + "/api/Funds/flatten/{asOfDate}";
        if (asOfDate === undefined || asOfDate === null)
            throw new globalThis.Error("The parameter 'asOfDate' must be defined.");
        url_ = url_.replace("{asOfDate}", encodeURIComponent(asOfDate ? "" + asOfDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFlatten(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFlatten(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processFlatten(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPositionsClient {
    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: PositionChangeDto | undefined): Observable<PositionChangeDto>;
    /**
     * @param date (optional) 
     * @return OK
     */
    day(date: Date | undefined): Observable<PositionDto[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    broadcastLock(body: PositionLockDto | undefined): Observable<void>;
}

@Injectable()
export class PositionsClient implements IPositionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: PositionChangeDto | undefined): Observable<PositionChangeDto> {
        let url_ = this.baseUrl + "/api/Positions/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PositionChangeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PositionChangeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PositionChangeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PositionChangeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param date (optional) 
     * @return OK
     */
    day(date: Date | undefined): Observable<PositionDto[]> {
        let url_ = this.baseUrl + "/api/Positions/day?";
        if (date === null)
            throw new globalThis.Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PositionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PositionDto[]>;
        }));
    }

    protected processDay(response: HttpResponseBase): Observable<PositionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PositionDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    broadcastLock(body: PositionLockDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Positions/broadcast-lock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBroadcastLock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBroadcastLock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBroadcastLock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRepoRatesClient {
    /**
     * @return OK
     */
    date(repoDate: Date): Observable<RepoRateDto[]>;
    /**
     * @param currentDate (optional) 
     * @return OK
     */
    previousDay(currentDate: Date | undefined): Observable<PreviousDayRepoRateDto[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    newDay(body: Date | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return Created
     */
    repoRatesPOST(body: CreateRepoRateDto | undefined): Observable<RepoRateDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    repoRatesPUT(id: number, body: UpdateRepoRateDto | undefined): Observable<boolean>;
    /**
     * @return OK
     */
    setInactive(id: number): Observable<RepoRateDto>;
    /**
     * @return OK
     */
    setActive(id: number): Observable<RepoRateDto>;
}

@Injectable()
export class RepoRatesClient implements IRepoRatesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    date(repoDate: Date): Observable<RepoRateDto[]> {
        let url_ = this.baseUrl + "/api/RepoRates/date/{repoDate}";
        if (repoDate === undefined || repoDate === null)
            throw new globalThis.Error("The parameter 'repoDate' must be defined.");
        url_ = url_.replace("{repoDate}", encodeURIComponent(repoDate ? "" + repoDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoRateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoRateDto[]>;
        }));
    }

    protected processDate(response: HttpResponseBase): Observable<RepoRateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoRateDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentDate (optional) 
     * @return OK
     */
    previousDay(currentDate: Date | undefined): Observable<PreviousDayRepoRateDto[]> {
        let url_ = this.baseUrl + "/api/RepoRates/previous-day?";
        if (currentDate === null)
            throw new globalThis.Error("The parameter 'currentDate' cannot be null.");
        else if (currentDate !== undefined)
            url_ += "currentDate=" + encodeURIComponent(currentDate ? "" + currentDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreviousDay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreviousDay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PreviousDayRepoRateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PreviousDayRepoRateDto[]>;
        }));
    }

    protected processPreviousDay(response: HttpResponseBase): Observable<PreviousDayRepoRateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PreviousDayRepoRateDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    newDay(body: Date | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/RepoRates/new-day";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewDay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewDay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processNewDay(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    repoRatesPOST(body: CreateRepoRateDto | undefined): Observable<RepoRateDto> {
        let url_ = this.baseUrl + "/api/RepoRates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRepoRatesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepoRatesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoRateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoRateDto>;
        }));
    }

    protected processRepoRatesPOST(response: HttpResponseBase): Observable<RepoRateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = RepoRateDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    repoRatesPUT(id: number, body: UpdateRepoRateDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/RepoRates/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRepoRatesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepoRatesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRepoRatesPUT(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    setInactive(id: number): Observable<RepoRateDto> {
        let url_ = this.baseUrl + "/api/RepoRates/{id}/set-inactive";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetInactive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetInactive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoRateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoRateDto>;
        }));
    }

    protected processSetInactive(response: HttpResponseBase): Observable<RepoRateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoRateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    setActive(id: number): Observable<RepoRateDto> {
        let url_ = this.baseUrl + "/api/RepoRates/{id}/set-active";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoRateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoRateDto>;
        }));
    }

    protected processSetActive(response: HttpResponseBase): Observable<RepoRateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoRateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRepoTradesClient {
    /**
     * @param fundId (optional) 
     * @param counterpartyId (optional) 
     * @param collateralTypeId (optional) 
     * @param startDateFrom (optional) 
     * @param startDateTo (optional) 
     * @param settlementDate (optional) 
     * @param status (optional) 
     * @param direction (optional) 
     * @return OK
     */
    search(fundId: number | undefined, counterpartyId: number | undefined, collateralTypeId: number | undefined, startDateFrom: Date | undefined, startDateTo: Date | undefined, settlementDate: Date | undefined, status: string | undefined, direction: string | undefined): Observable<RepoTradeDto[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    submit(body: number[] | undefined): Observable<RepoTradeDto[]>;
}

@Injectable()
export class RepoTradesClient implements IRepoTradesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param fundId (optional) 
     * @param counterpartyId (optional) 
     * @param collateralTypeId (optional) 
     * @param startDateFrom (optional) 
     * @param startDateTo (optional) 
     * @param settlementDate (optional) 
     * @param status (optional) 
     * @param direction (optional) 
     * @return OK
     */
    search(fundId: number | undefined, counterpartyId: number | undefined, collateralTypeId: number | undefined, startDateFrom: Date | undefined, startDateTo: Date | undefined, settlementDate: Date | undefined, status: string | undefined, direction: string | undefined): Observable<RepoTradeDto[]> {
        let url_ = this.baseUrl + "/api/RepoTrades/search?";
        if (fundId === null)
            throw new globalThis.Error("The parameter 'fundId' cannot be null.");
        else if (fundId !== undefined)
            url_ += "FundId=" + encodeURIComponent("" + fundId) + "&";
        if (counterpartyId === null)
            throw new globalThis.Error("The parameter 'counterpartyId' cannot be null.");
        else if (counterpartyId !== undefined)
            url_ += "CounterpartyId=" + encodeURIComponent("" + counterpartyId) + "&";
        if (collateralTypeId === null)
            throw new globalThis.Error("The parameter 'collateralTypeId' cannot be null.");
        else if (collateralTypeId !== undefined)
            url_ += "CollateralTypeId=" + encodeURIComponent("" + collateralTypeId) + "&";
        if (startDateFrom === null)
            throw new globalThis.Error("The parameter 'startDateFrom' cannot be null.");
        else if (startDateFrom !== undefined)
            url_ += "StartDateFrom=" + encodeURIComponent(startDateFrom ? "" + startDateFrom.toISOString() : "") + "&";
        if (startDateTo === null)
            throw new globalThis.Error("The parameter 'startDateTo' cannot be null.");
        else if (startDateTo !== undefined)
            url_ += "StartDateTo=" + encodeURIComponent(startDateTo ? "" + startDateTo.toISOString() : "") + "&";
        if (settlementDate === null)
            throw new globalThis.Error("The parameter 'settlementDate' cannot be null.");
        else if (settlementDate !== undefined)
            url_ += "SettlementDate=" + encodeURIComponent(settlementDate ? "" + settlementDate.toISOString() : "") + "&";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (direction === null)
            throw new globalThis.Error("The parameter 'direction' cannot be null.");
        else if (direction !== undefined)
            url_ += "Direction=" + encodeURIComponent("" + direction) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoTradeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoTradeDto[]>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<RepoTradeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoTradeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    submit(body: number[] | undefined): Observable<RepoTradeDto[]> {
        let url_ = this.baseUrl + "/api/RepoTrades/submit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoTradeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoTradeDto[]>;
        }));
    }

    protected processSubmit(response: HttpResponseBase): Observable<RepoTradeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoTradeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISecuritiesClient {
    /**
     * @return OK
     */
    securitiesAll(): Observable<SecurityDto[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    securitiesPOST(body: CreateSecurityDto | undefined): Observable<SecurityDto>;
    /**
     * @return OK
     */
    securitiesGET(id: number): Observable<SecurityDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    securitiesPUT(id: number, body: UpdateSecurityDto | undefined): Observable<SecurityDto>;
    /**
     * @return OK
     */
    securitiesDELETE(id: number): Observable<void>;
    /**
     * @return OK
     */
    isin(isin: string): Observable<SecurityDto>;
    /**
     * @return OK
     */
    type(assetType: string): Observable<SecurityDto[]>;
}

@Injectable()
export class SecuritiesClient implements ISecuritiesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    securitiesAll(): Observable<SecurityDto[]> {
        let url_ = this.baseUrl + "/api/Securities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSecuritiesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSecuritiesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityDto[]>;
        }));
    }

    protected processSecuritiesAll(response: HttpResponseBase): Observable<SecurityDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SecurityDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    securitiesPOST(body: CreateSecurityDto | undefined): Observable<SecurityDto> {
        let url_ = this.baseUrl + "/api/Securities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSecuritiesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSecuritiesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityDto>;
        }));
    }

    protected processSecuritiesPOST(response: HttpResponseBase): Observable<SecurityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    securitiesGET(id: number): Observable<SecurityDto> {
        let url_ = this.baseUrl + "/api/Securities/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSecuritiesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSecuritiesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityDto>;
        }));
    }

    protected processSecuritiesGET(response: HttpResponseBase): Observable<SecurityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    securitiesPUT(id: number, body: UpdateSecurityDto | undefined): Observable<SecurityDto> {
        let url_ = this.baseUrl + "/api/Securities/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSecuritiesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSecuritiesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityDto>;
        }));
    }

    protected processSecuritiesPUT(response: HttpResponseBase): Observable<SecurityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    securitiesDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Securities/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSecuritiesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSecuritiesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSecuritiesDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    isin(isin: string): Observable<SecurityDto> {
        let url_ = this.baseUrl + "/api/Securities/isin/{isin}";
        if (isin === undefined || isin === null)
            throw new globalThis.Error("The parameter 'isin' must be defined.");
        url_ = url_.replace("{isin}", encodeURIComponent("" + isin));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityDto>;
        }));
    }

    protected processIsin(response: HttpResponseBase): Observable<SecurityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    type(assetType: string): Observable<SecurityDto[]> {
        let url_ = this.baseUrl + "/api/Securities/type/{assetType}";
        if (assetType === undefined || assetType === null)
            throw new globalThis.Error("The parameter 'assetType' must be defined.");
        url_ = url_.replace("{assetType}", encodeURIComponent("" + assetType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityDto[]>;
        }));
    }

    protected processType(response: HttpResponseBase): Observable<SecurityDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SecurityDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AccountCashflowsDto implements IAccountCashflowsDto {
    cashAccountId?: number;
    accountName?: string | undefined;
    currencyCode?: string | undefined;
    cashflows?: CashflowDto[] | undefined;

    constructor(data?: IAccountCashflowsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cashAccountId = _data["cashAccountId"];
            this.accountName = _data["accountName"];
            this.currencyCode = _data["currencyCode"];
            if (Array.isArray(_data["cashflows"])) {
                this.cashflows = [] as any;
                for (let item of _data["cashflows"])
                    this.cashflows!.push(CashflowDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountCashflowsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountCashflowsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashAccountId"] = this.cashAccountId;
        data["accountName"] = this.accountName;
        data["currencyCode"] = this.currencyCode;
        if (Array.isArray(this.cashflows)) {
            data["cashflows"] = [];
            for (let item of this.cashflows)
                data["cashflows"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IAccountCashflowsDto {
    cashAccountId?: number;
    accountName?: string | undefined;
    currencyCode?: string | undefined;
    cashflows?: CashflowDto[] | undefined;
}

export class AuthenticationRequest implements IAuthenticationRequest {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: IAuthenticationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IAuthenticationRequest {
    email?: string | undefined;
    password?: string | undefined;
}

export class AuthenticationResponse implements IAuthenticationResponse {
    userId?: number;
    token?: string | undefined;
    email?: string | undefined;
    displayName?: string | undefined;

    constructor(data?: IAuthenticationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.token = _data["token"];
            this.email = _data["email"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AuthenticationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["token"] = this.token;
        data["email"] = this.email;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAuthenticationResponse {
    userId?: number;
    token?: string | undefined;
    email?: string | undefined;
    displayName?: string | undefined;
}

export class CashflowDto implements ICashflowDto {
    id?: number;
    cashAccountId?: number;
    accountNumber?: string | undefined;
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    repoTradeId?: number | undefined;
    tradeReference?: string | undefined;
    amount?: number;
    currencyCode?: string | undefined;
    effectiveDate?: Date;
    description?: string | undefined;
    source?: string | undefined;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: ICashflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cashAccountId = _data["cashAccountId"];
            this.accountNumber = _data["accountNumber"];
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.repoTradeId = _data["repoTradeId"];
            this.tradeReference = _data["tradeReference"];
            this.amount = _data["amount"];
            this.currencyCode = _data["currencyCode"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : undefined as any;
            this.description = _data["description"];
            this.source = _data["source"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): CashflowDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cashAccountId"] = this.cashAccountId;
        data["accountNumber"] = this.accountNumber;
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["repoTradeId"] = this.repoTradeId;
        data["tradeReference"] = this.tradeReference;
        data["amount"] = this.amount;
        data["currencyCode"] = this.currencyCode;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : undefined as any;
        data["description"] = this.description;
        data["source"] = this.source;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface ICashflowDto {
    id?: number;
    cashAccountId?: number;
    accountNumber?: string | undefined;
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    repoTradeId?: number | undefined;
    tradeReference?: string | undefined;
    amount?: number;
    currencyCode?: string | undefined;
    effectiveDate?: Date;
    description?: string | undefined;
    source?: string | undefined;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class CollateralTypeDto implements ICollateralTypeDto {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    standardHaircut?: number | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: ICollateralTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.standardHaircut = _data["standardHaircut"];
            this.isActive = _data["isActive"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): CollateralTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollateralTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["standardHaircut"] = this.standardHaircut;
        data["isActive"] = this.isActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface ICollateralTypeDto {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    standardHaircut?: number | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class CounterpartyDto implements ICounterpartyDto {
    id?: number;
    name?: string | undefined;
    shortName?: string | undefined;
    country?: string | undefined;
    creditRating?: string | undefined;
    sector?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: ICounterpartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            this.country = _data["country"];
            this.creditRating = _data["creditRating"];
            this.sector = _data["sector"];
            this.isActive = _data["isActive"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): CounterpartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["country"] = this.country;
        data["creditRating"] = this.creditRating;
        data["sector"] = this.sector;
        data["isActive"] = this.isActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface ICounterpartyDto {
    id?: number;
    name?: string | undefined;
    shortName?: string | undefined;
    country?: string | undefined;
    creditRating?: string | undefined;
    sector?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class CreateCashflowDto implements ICreateCashflowDto {
    cashAccountId?: number;
    fundId?: number;
    repoTradeId?: number | undefined;
    amount?: number;
    currencyCode?: string | undefined;
    cashflowDate?: Date;
    description?: string | undefined;
    source?: string | undefined;
    createdByUserId?: number;

    constructor(data?: ICreateCashflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cashAccountId = _data["cashAccountId"];
            this.fundId = _data["fundId"];
            this.repoTradeId = _data["repoTradeId"];
            this.amount = _data["amount"];
            this.currencyCode = _data["currencyCode"];
            this.cashflowDate = _data["cashflowDate"] ? new Date(_data["cashflowDate"].toString()) : undefined as any;
            this.description = _data["description"];
            this.source = _data["source"];
            this.createdByUserId = _data["createdByUserId"];
        }
    }

    static fromJS(data: any): CreateCashflowDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCashflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashAccountId"] = this.cashAccountId;
        data["fundId"] = this.fundId;
        data["repoTradeId"] = this.repoTradeId;
        data["amount"] = this.amount;
        data["currencyCode"] = this.currencyCode;
        data["cashflowDate"] = this.cashflowDate ? this.cashflowDate.toISOString() : undefined as any;
        data["description"] = this.description;
        data["source"] = this.source;
        data["createdByUserId"] = this.createdByUserId;
        return data;
    }
}

export interface ICreateCashflowDto {
    cashAccountId?: number;
    fundId?: number;
    repoTradeId?: number | undefined;
    amount?: number;
    currencyCode?: string | undefined;
    cashflowDate?: Date;
    description?: string | undefined;
    source?: string | undefined;
    createdByUserId?: number;
}

export class CreateRepoRateDto implements ICreateRepoRateDto {
    counterpartyId?: number;
    collateralTypeId?: number;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean;
    createdByUserId?: number;

    constructor(data?: ICreateRepoRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.counterpartyId = _data["counterpartyId"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.repoDate = _data["repoDate"] ? new Date(_data["repoDate"].toString()) : undefined as any;
            this.repoRate = _data["repoRate"];
            this.targetCircle = _data["targetCircle"];
            this.finalCircle = _data["finalCircle"];
            this.active = _data["active"];
            this.createdByUserId = _data["createdByUserId"];
        }
    }

    static fromJS(data: any): CreateRepoRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRepoRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counterpartyId"] = this.counterpartyId;
        data["collateralTypeId"] = this.collateralTypeId;
        data["repoDate"] = this.repoDate ? this.repoDate.toISOString() : undefined as any;
        data["repoRate"] = this.repoRate;
        data["targetCircle"] = this.targetCircle;
        data["finalCircle"] = this.finalCircle;
        data["active"] = this.active;
        data["createdByUserId"] = this.createdByUserId;
        return data;
    }
}

export interface ICreateRepoRateDto {
    counterpartyId?: number;
    collateralTypeId?: number;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean;
    createdByUserId?: number;
}

export class CreateSecurityDto implements ICreateSecurityDto {
    isin?: string | undefined;
    description?: string | undefined;
    name?: string | undefined;
    assetType?: string | undefined;
    issuer?: string | undefined;
    currency?: string | undefined;
    maturityDate?: Date | undefined;
    createdByUserId?: number;

    constructor(data?: ICreateSecurityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isin = _data["isin"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.assetType = _data["assetType"];
            this.issuer = _data["issuer"];
            this.currency = _data["currency"];
            this.maturityDate = _data["maturityDate"] ? new Date(_data["maturityDate"].toString()) : undefined as any;
            this.createdByUserId = _data["createdByUserId"];
        }
    }

    static fromJS(data: any): CreateSecurityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSecurityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isin"] = this.isin;
        data["description"] = this.description;
        data["name"] = this.name;
        data["assetType"] = this.assetType;
        data["issuer"] = this.issuer;
        data["currency"] = this.currency;
        data["maturityDate"] = this.maturityDate ? this.maturityDate.toISOString() : undefined as any;
        data["createdByUserId"] = this.createdByUserId;
        return data;
    }
}

export interface ICreateSecurityDto {
    isin?: string | undefined;
    description?: string | undefined;
    name?: string | undefined;
    assetType?: string | undefined;
    issuer?: string | undefined;
    currency?: string | undefined;
    maturityDate?: Date | undefined;
    createdByUserId?: number;
}

export class FundAccountCashflowsDto implements IFundAccountCashflowsDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    accounts?: AccountCashflowsDto[] | undefined;

    constructor(data?: IFundAccountCashflowsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            if (Array.isArray(_data["accounts"])) {
                this.accounts = [] as any;
                for (let item of _data["accounts"])
                    this.accounts!.push(AccountCashflowsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FundAccountCashflowsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FundAccountCashflowsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        if (Array.isArray(this.accounts)) {
            data["accounts"] = [];
            for (let item of this.accounts)
                data["accounts"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IFundAccountCashflowsDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    accounts?: AccountCashflowsDto[] | undefined;
}

export class FundBalanceDto implements IFundBalanceDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    availableCash?: number;
    openingBalance?: number | undefined;
    asOfDate?: Date;

    constructor(data?: IFundBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.currencyCode = _data["currencyCode"];
            this.availableCash = _data["availableCash"];
            this.openingBalance = _data["openingBalance"];
            this.asOfDate = _data["asOfDate"] ? new Date(_data["asOfDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): FundBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new FundBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["currencyCode"] = this.currencyCode;
        data["availableCash"] = this.availableCash;
        data["openingBalance"] = this.openingBalance;
        data["asOfDate"] = this.asOfDate ? this.asOfDate.toISOString() : undefined as any;
        return data;
    }
}

export interface IFundBalanceDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    availableCash?: number;
    openingBalance?: number | undefined;
    asOfDate?: Date;
}

export class PositionChangeDto implements IPositionChangeDto {
    collateralTypeId?: number;
    counterpartyId?: number;
    securityId?: number;
    securityMaturityDate?: Date;
    fundId?: number;
    newNotionalAmount?: number;
    newVariance?: number;
    status?: string | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IPositionChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collateralTypeId = _data["collateralTypeId"];
            this.counterpartyId = _data["counterpartyId"];
            this.securityId = _data["securityId"];
            this.securityMaturityDate = _data["securityMaturityDate"] ? new Date(_data["securityMaturityDate"].toString()) : undefined as any;
            this.fundId = _data["fundId"];
            this.newNotionalAmount = _data["newNotionalAmount"];
            this.newVariance = _data["newVariance"];
            this.status = _data["status"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): PositionChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PositionChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collateralTypeId"] = this.collateralTypeId;
        data["counterpartyId"] = this.counterpartyId;
        data["securityId"] = this.securityId;
        data["securityMaturityDate"] = this.securityMaturityDate ? this.securityMaturityDate.toISOString() : undefined as any;
        data["fundId"] = this.fundId;
        data["newNotionalAmount"] = this.newNotionalAmount;
        data["newVariance"] = this.newVariance;
        data["status"] = this.status;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IPositionChangeDto {
    collateralTypeId?: number;
    counterpartyId?: number;
    securityId?: number;
    securityMaturityDate?: Date;
    fundId?: number;
    newNotionalAmount?: number;
    newVariance?: number;
    status?: string | undefined;
    errorMessage?: string | undefined;
}

export class PositionDto implements IPositionDto {
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    securityId?: number;
    variance?: number;
    rate?: number;
    securityName?: string | undefined;
    securityMaturityDate?: Date;
    fundNotionals?: { [key: string]: number; } | undefined;
    exposurePercentages?: { [key: string]: number; } | undefined;
    statuses?: { [key: string]: string; } | undefined;
    commitStatus?: { [key: string]: string; } | undefined;

    constructor(data?: IPositionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collateralTypeId = _data["collateralTypeId"];
            this.collateralTypeName = _data["collateralTypeName"];
            this.counterpartyId = _data["counterpartyId"];
            this.counterpartyName = _data["counterpartyName"];
            this.securityId = _data["securityId"];
            this.variance = _data["variance"];
            this.rate = _data["rate"];
            this.securityName = _data["securityName"];
            this.securityMaturityDate = _data["securityMaturityDate"] ? new Date(_data["securityMaturityDate"].toString()) : undefined as any;
            if (_data["fundNotionals"]) {
                this.fundNotionals = {} as any;
                for (let key in _data["fundNotionals"]) {
                    if (_data["fundNotionals"].hasOwnProperty(key))
                        (this.fundNotionals as any)![key] = _data["fundNotionals"][key];
                }
            }
            if (_data["exposurePercentages"]) {
                this.exposurePercentages = {} as any;
                for (let key in _data["exposurePercentages"]) {
                    if (_data["exposurePercentages"].hasOwnProperty(key))
                        (this.exposurePercentages as any)![key] = _data["exposurePercentages"][key];
                }
            }
            if (_data["statuses"]) {
                this.statuses = {} as any;
                for (let key in _data["statuses"]) {
                    if (_data["statuses"].hasOwnProperty(key))
                        (this.statuses as any)![key] = _data["statuses"][key];
                }
            }
            if (_data["commitStatus"]) {
                this.commitStatus = {} as any;
                for (let key in _data["commitStatus"]) {
                    if (_data["commitStatus"].hasOwnProperty(key))
                        (this.commitStatus as any)![key] = _data["commitStatus"][key];
                }
            }
        }
    }

    static fromJS(data: any): PositionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PositionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collateralTypeId"] = this.collateralTypeId;
        data["collateralTypeName"] = this.collateralTypeName;
        data["counterpartyId"] = this.counterpartyId;
        data["counterpartyName"] = this.counterpartyName;
        data["securityId"] = this.securityId;
        data["variance"] = this.variance;
        data["rate"] = this.rate;
        data["securityName"] = this.securityName;
        data["securityMaturityDate"] = this.securityMaturityDate ? this.securityMaturityDate.toISOString() : undefined as any;
        if (this.fundNotionals) {
            data["fundNotionals"] = {};
            for (let key in this.fundNotionals) {
                if (this.fundNotionals.hasOwnProperty(key))
                    (data["fundNotionals"] as any)[key] = (this.fundNotionals as any)[key];
            }
        }
        if (this.exposurePercentages) {
            data["exposurePercentages"] = {};
            for (let key in this.exposurePercentages) {
                if (this.exposurePercentages.hasOwnProperty(key))
                    (data["exposurePercentages"] as any)[key] = (this.exposurePercentages as any)[key];
            }
        }
        if (this.statuses) {
            data["statuses"] = {};
            for (let key in this.statuses) {
                if (this.statuses.hasOwnProperty(key))
                    (data["statuses"] as any)[key] = (this.statuses as any)[key];
            }
        }
        if (this.commitStatus) {
            data["commitStatus"] = {};
            for (let key in this.commitStatus) {
                if (this.commitStatus.hasOwnProperty(key))
                    (data["commitStatus"] as any)[key] = (this.commitStatus as any)[key];
            }
        }
        return data;
    }
}

export interface IPositionDto {
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    securityId?: number;
    variance?: number;
    rate?: number;
    securityName?: string | undefined;
    securityMaturityDate?: Date;
    fundNotionals?: { [key: string]: number; } | undefined;
    exposurePercentages?: { [key: string]: number; } | undefined;
    statuses?: { [key: string]: string; } | undefined;
    commitStatus?: { [key: string]: string; } | undefined;
}

export class PositionLockDto implements IPositionLockDto {
    counterpartyId?: number;
    collateralTypeId?: number;
    fundId?: number;
    locked?: boolean;
    userDisplay?: string | undefined;

    constructor(data?: IPositionLockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.counterpartyId = _data["counterpartyId"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.fundId = _data["fundId"];
            this.locked = _data["locked"];
            this.userDisplay = _data["userDisplay"];
        }
    }

    static fromJS(data: any): PositionLockDto {
        data = typeof data === 'object' ? data : {};
        let result = new PositionLockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counterpartyId"] = this.counterpartyId;
        data["collateralTypeId"] = this.collateralTypeId;
        data["fundId"] = this.fundId;
        data["locked"] = this.locked;
        data["userDisplay"] = this.userDisplay;
        return data;
    }
}

export interface IPositionLockDto {
    counterpartyId?: number;
    collateralTypeId?: number;
    fundId?: number;
    locked?: boolean;
    userDisplay?: string | undefined;
}

export class PreviousDayRepoRateDto implements IPreviousDayRepoRateDto {
    id?: number;
    counterpartyId?: number;
    collateralTypeId?: number;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number;
    active?: boolean;

    constructor(data?: IPreviousDayRepoRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.counterpartyId = _data["counterpartyId"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.repoDate = _data["repoDate"] ? new Date(_data["repoDate"].toString()) : undefined as any;
            this.repoRate = _data["repoRate"];
            this.targetCircle = _data["targetCircle"];
            this.finalCircle = _data["finalCircle"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): PreviousDayRepoRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PreviousDayRepoRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["counterpartyId"] = this.counterpartyId;
        data["collateralTypeId"] = this.collateralTypeId;
        data["repoDate"] = this.repoDate ? this.repoDate.toISOString() : undefined as any;
        data["repoRate"] = this.repoRate;
        data["targetCircle"] = this.targetCircle;
        data["finalCircle"] = this.finalCircle;
        data["active"] = this.active;
        return data;
    }
}

export interface IPreviousDayRepoRateDto {
    id?: number;
    counterpartyId?: number;
    collateralTypeId?: number;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number;
    active?: boolean;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class RepoRateDto implements IRepoRateDto {
    id?: number;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: IRepoRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.counterpartyId = _data["counterpartyId"];
            this.counterpartyName = _data["counterpartyName"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.collateralTypeName = _data["collateralTypeName"];
            this.repoDate = _data["repoDate"] ? new Date(_data["repoDate"].toString()) : undefined as any;
            this.repoRate = _data["repoRate"];
            this.targetCircle = _data["targetCircle"];
            this.finalCircle = _data["finalCircle"];
            this.active = _data["active"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): RepoRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepoRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["counterpartyId"] = this.counterpartyId;
        data["counterpartyName"] = this.counterpartyName;
        data["collateralTypeId"] = this.collateralTypeId;
        data["collateralTypeName"] = this.collateralTypeName;
        data["repoDate"] = this.repoDate ? this.repoDate.toISOString() : undefined as any;
        data["repoRate"] = this.repoRate;
        data["targetCircle"] = this.targetCircle;
        data["finalCircle"] = this.finalCircle;
        data["active"] = this.active;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface IRepoRateDto {
    id?: number;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class RepoTradeDto implements IRepoTradeDto {
    id?: number;
    tradeReference?: string | undefined;
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    securityId?: number;
    securityIsin?: string | undefined;
    securityName?: string | undefined;
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    direction?: string | undefined;
    notional?: number;
    rate?: number;
    startDate?: Date;
    endDate?: Date;
    settlementDate?: Date;
    status?: string | undefined;
    currency?: string | undefined;
    haircut?: number | undefined;
    collateralValue?: number | undefined;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
    security?: SecurityDto;

    constructor(data?: IRepoTradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tradeReference = _data["tradeReference"];
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.counterpartyId = _data["counterpartyId"];
            this.counterpartyName = _data["counterpartyName"];
            this.securityId = _data["securityId"];
            this.securityIsin = _data["securityIsin"];
            this.securityName = _data["securityName"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.collateralTypeName = _data["collateralTypeName"];
            this.direction = _data["direction"];
            this.notional = _data["notional"];
            this.rate = _data["rate"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : undefined as any;
            this.settlementDate = _data["settlementDate"] ? new Date(_data["settlementDate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.currency = _data["currency"];
            this.haircut = _data["haircut"];
            this.collateralValue = _data["collateralValue"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
            this.security = _data["security"] ? SecurityDto.fromJS(_data["security"]) : undefined as any;
        }
    }

    static fromJS(data: any): RepoTradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepoTradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tradeReference"] = this.tradeReference;
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["counterpartyId"] = this.counterpartyId;
        data["counterpartyName"] = this.counterpartyName;
        data["securityId"] = this.securityId;
        data["securityIsin"] = this.securityIsin;
        data["securityName"] = this.securityName;
        data["collateralTypeId"] = this.collateralTypeId;
        data["collateralTypeName"] = this.collateralTypeName;
        data["direction"] = this.direction;
        data["notional"] = this.notional;
        data["rate"] = this.rate;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : undefined as any;
        data["settlementDate"] = this.settlementDate ? this.settlementDate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["currency"] = this.currency;
        data["haircut"] = this.haircut;
        data["collateralValue"] = this.collateralValue;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        data["security"] = this.security ? this.security.toJSON() : undefined as any;
        return data;
    }
}

export interface IRepoTradeDto {
    id?: number;
    tradeReference?: string | undefined;
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    securityId?: number;
    securityIsin?: string | undefined;
    securityName?: string | undefined;
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    direction?: string | undefined;
    notional?: number;
    rate?: number;
    startDate?: Date;
    endDate?: Date;
    settlementDate?: Date;
    status?: string | undefined;
    currency?: string | undefined;
    haircut?: number | undefined;
    collateralValue?: number | undefined;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
    security?: SecurityDto;
}

export class SecurityDto implements ISecurityDto {
    id?: number;
    isin?: string | undefined;
    description?: string | undefined;
    assetType?: string | undefined;
    issuer?: string | undefined;
    currency?: string | undefined;
    maturityDate?: Date | undefined;
    createdByUserId?: number;
    createdDate?: Date;
    modifiedByUserId?: number | undefined;
    modifiedDate?: Date | undefined;

    constructor(data?: ISecurityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isin = _data["isin"];
            this.description = _data["description"];
            this.assetType = _data["assetType"];
            this.issuer = _data["issuer"];
            this.currency = _data["currency"];
            this.maturityDate = _data["maturityDate"] ? new Date(_data["maturityDate"].toString()) : undefined as any;
            this.createdByUserId = _data["createdByUserId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.modifiedByUserId = _data["modifiedByUserId"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): SecurityDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isin"] = this.isin;
        data["description"] = this.description;
        data["assetType"] = this.assetType;
        data["issuer"] = this.issuer;
        data["currency"] = this.currency;
        data["maturityDate"] = this.maturityDate ? this.maturityDate.toISOString() : undefined as any;
        data["createdByUserId"] = this.createdByUserId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["modifiedByUserId"] = this.modifiedByUserId;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        return data;
    }
}

export interface ISecurityDto {
    id?: number;
    isin?: string | undefined;
    description?: string | undefined;
    assetType?: string | undefined;
    issuer?: string | undefined;
    currency?: string | undefined;
    maturityDate?: Date | undefined;
    createdByUserId?: number;
    createdDate?: Date;
    modifiedByUserId?: number | undefined;
    modifiedDate?: Date | undefined;
}

export class UpdateRepoRateDto implements IUpdateRepoRateDto {
    id?: number;
    counterpartyId?: number;
    collateralTypeId?: number;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean | undefined;
    modifiedByUserId?: number;

    constructor(data?: IUpdateRepoRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.counterpartyId = _data["counterpartyId"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.repoRate = _data["repoRate"];
            this.targetCircle = _data["targetCircle"];
            this.finalCircle = _data["finalCircle"];
            this.active = _data["active"];
            this.modifiedByUserId = _data["modifiedByUserId"];
        }
    }

    static fromJS(data: any): UpdateRepoRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRepoRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["counterpartyId"] = this.counterpartyId;
        data["collateralTypeId"] = this.collateralTypeId;
        data["repoRate"] = this.repoRate;
        data["targetCircle"] = this.targetCircle;
        data["finalCircle"] = this.finalCircle;
        data["active"] = this.active;
        data["modifiedByUserId"] = this.modifiedByUserId;
        return data;
    }
}

export interface IUpdateRepoRateDto {
    id?: number;
    counterpartyId?: number;
    collateralTypeId?: number;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean | undefined;
    modifiedByUserId?: number;
}

export class UpdateSecurityDto implements IUpdateSecurityDto {
    id?: number;
    description?: string | undefined;
    assetType?: string | undefined;
    issuer?: string | undefined;
    currency?: string | undefined;
    maturityDate?: Date | undefined;
    isActive?: boolean;
    modifiedByUserId?: number;

    constructor(data?: IUpdateSecurityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.assetType = _data["assetType"];
            this.issuer = _data["issuer"];
            this.currency = _data["currency"];
            this.maturityDate = _data["maturityDate"] ? new Date(_data["maturityDate"].toString()) : undefined as any;
            this.isActive = _data["isActive"];
            this.modifiedByUserId = _data["modifiedByUserId"];
        }
    }

    static fromJS(data: any): UpdateSecurityDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSecurityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["assetType"] = this.assetType;
        data["issuer"] = this.issuer;
        data["currency"] = this.currency;
        data["maturityDate"] = this.maturityDate ? this.maturityDate.toISOString() : undefined as any;
        data["isActive"] = this.isActive;
        data["modifiedByUserId"] = this.modifiedByUserId;
        return data;
    }
}

export interface IUpdateSecurityDto {
    id?: number;
    description?: string | undefined;
    assetType?: string | undefined;
    issuer?: string | undefined;
    currency?: string | undefined;
    maturityDate?: Date | undefined;
    isActive?: boolean;
    modifiedByUserId?: number;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}