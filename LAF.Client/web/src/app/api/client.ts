//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: AuthenticationRequest | undefined): Promise<AuthenticationResponse> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<AuthenticationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthenticationResponse>(null as any);
    }

    /**
     * @return OK
     */
    counterpartiesAll(): Promise<CounterpartyDto[]> {
        let url_ = this.baseUrl + "/api/Counterparties";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCounterpartiesAll(_response);
        });
    }

    protected processCounterpartiesAll(response: Response): Promise<CounterpartyDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CounterpartyDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterpartyDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    counterpartiesPOST(body: CreateCounterpartyDto | undefined): Promise<CounterpartyDto> {
        let url_ = this.baseUrl + "/api/Counterparties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCounterpartiesPOST(_response);
        });
    }

    protected processCounterpartiesPOST(response: Response): Promise<CounterpartyDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CounterpartyDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterpartyDto>(null as any);
    }

    /**
     * @return OK
     */
    active(): Promise<CounterpartyDto[]> {
        let url_ = this.baseUrl + "/api/Counterparties/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActive(_response);
        });
    }

    protected processActive(response: Response): Promise<CounterpartyDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CounterpartyDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterpartyDto[]>(null as any);
    }

    /**
     * @return OK
     */
    counterpartiesGET(id: number): Promise<CounterpartyDto> {
        let url_ = this.baseUrl + "/api/Counterparties/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCounterpartiesGET(_response);
        });
    }

    protected processCounterpartiesGET(response: Response): Promise<CounterpartyDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CounterpartyDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterpartyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    counterpartiesPUT(id: number, body: UpdateCounterpartyDto | undefined): Promise<CounterpartyDto> {
        let url_ = this.baseUrl + "/api/Counterparties/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCounterpartiesPUT(_response);
        });
    }

    protected processCounterpartiesPUT(response: Response): Promise<CounterpartyDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CounterpartyDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterpartyDto>(null as any);
    }

    /**
     * @return OK
     */
    exposure(id: number, tradeDate: Date): Promise<CounterpartyExposureDto> {
        let url_ = this.baseUrl + "/api/Counterparties/{id}/exposure/{tradeDate}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (tradeDate === undefined || tradeDate === null)
            throw new globalThis.Error("The parameter 'tradeDate' must be defined.");
        url_ = url_.replace("{tradeDate}", encodeURIComponent(tradeDate ? "" + tradeDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExposure(_response);
        });
    }

    protected processExposure(response: Response): Promise<CounterpartyExposureDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CounterpartyExposureDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterpartyExposureDto>(null as any);
    }

    /**
     * @return OK
     */
    exposures(tradeDate: Date): Promise<CounterpartyExposureDto[]> {
        let url_ = this.baseUrl + "/api/Counterparties/exposures/{tradeDate}";
        if (tradeDate === undefined || tradeDate === null)
            throw new globalThis.Error("The parameter 'tradeDate' must be defined.");
        url_ = url_.replace("{tradeDate}", encodeURIComponent(tradeDate ? "" + tradeDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExposures(_response);
        });
    }

    protected processExposures(response: Response): Promise<CounterpartyExposureDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CounterpartyExposureDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterpartyExposureDto[]>(null as any);
    }

    /**
     * @return OK
     */
    limitBreaches(tradeDate: Date): Promise<CounterpartyExposureDto[]> {
        let url_ = this.baseUrl + "/api/Counterparties/limit-breaches/{tradeDate}";
        if (tradeDate === undefined || tradeDate === null)
            throw new globalThis.Error("The parameter 'tradeDate' must be defined.");
        url_ = url_.replace("{tradeDate}", encodeURIComponent(tradeDate ? "" + tradeDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLimitBreaches(_response);
        });
    }

    protected processLimitBreaches(response: Response): Promise<CounterpartyExposureDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CounterpartyExposureDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterpartyExposureDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    importCashBalances(body: EagleImportRequestDto | undefined): Promise<EagleImportResponseDto> {
        let url_ = this.baseUrl + "/api/EagleIntegration/import-cash-balances";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImportCashBalances(_response);
        });
    }

    protected processImportCashBalances(response: Response): Promise<EagleImportResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EagleImportResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EagleImportResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    exportEndOfDayBalances(body: EagleExportRequestDto | undefined): Promise<EagleExportResponseDto> {
        let url_ = this.baseUrl + "/api/EagleIntegration/export-end-of-day-balances";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExportEndOfDayBalances(_response);
        });
    }

    protected processExportEndOfDayBalances(response: Response): Promise<EagleExportResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EagleExportResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EagleExportResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    generateFlatFundBalances(body: EagleExportRequestDto | undefined): Promise<EagleExportResponseDto> {
        let url_ = this.baseUrl + "/api/EagleIntegration/generate-flat-fund-balances";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateFlatFundBalances(_response);
        });
    }

    protected processGenerateFlatFundBalances(response: Response): Promise<EagleExportResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EagleExportResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EagleExportResponseDto>(null as any);
    }

    /**
     * @return OK
     */
    prepareEndOfDayBalances(exportDate: Date): Promise<FundBalanceExportDto[]> {
        let url_ = this.baseUrl + "/api/EagleIntegration/prepare-end-of-day-balances/{exportDate}";
        if (exportDate === undefined || exportDate === null)
            throw new globalThis.Error("The parameter 'exportDate' must be defined.");
        url_ = url_.replace("{exportDate}", encodeURIComponent(exportDate ? "" + exportDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrepareEndOfDayBalances(_response);
        });
    }

    protected processPrepareEndOfDayBalances(response: Response): Promise<FundBalanceExportDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FundBalanceExportDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FundBalanceExportDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validateImportData(body: EagleImportRequestDto | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/EagleIntegration/validate-import-data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateImportData(_response);
        });
    }

    protected processValidateImportData(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param fundCode (optional) 
     * @param openingBalance (optional) 
     * @param currency (optional) 
     * @param balanceDate (optional) 
     * @return OK
     */
    processCashBalance(fundCode: string | undefined, openingBalance: number | undefined, currency: string | undefined, balanceDate: Date | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/EagleIntegration/process-cash-balance?";
        if (fundCode === null)
            throw new globalThis.Error("The parameter 'fundCode' cannot be null.");
        else if (fundCode !== undefined)
            url_ += "fundCode=" + encodeURIComponent("" + fundCode) + "&";
        if (openingBalance === null)
            throw new globalThis.Error("The parameter 'openingBalance' cannot be null.");
        else if (openingBalance !== undefined)
            url_ += "openingBalance=" + encodeURIComponent("" + openingBalance) + "&";
        if (currency === null)
            throw new globalThis.Error("The parameter 'currency' cannot be null.");
        else if (currency !== undefined)
            url_ += "currency=" + encodeURIComponent("" + currency) + "&";
        if (balanceDate === null)
            throw new globalThis.Error("The parameter 'balanceDate' cannot be null.");
        else if (balanceDate !== undefined)
            url_ += "balanceDate=" + encodeURIComponent(balanceDate ? "" + balanceDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProcessCashBalance(_response);
        });
    }

    protected processProcessCashBalance(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return OK
     */
    fundsAll(): Promise<FundDto[]> {
        let url_ = this.baseUrl + "/api/Funds";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFundsAll(_response);
        });
    }

    protected processFundsAll(response: Response): Promise<FundDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FundDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FundDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    fundsPOST(body: CreateFundDto | undefined): Promise<FundDto> {
        let url_ = this.baseUrl + "/api/Funds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFundsPOST(_response);
        });
    }

    protected processFundsPOST(response: Response): Promise<FundDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FundDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FundDto>(null as any);
    }

    /**
     * @return OK
     */
    active2(): Promise<FundDto[]> {
        let url_ = this.baseUrl + "/api/Funds/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActive2(_response);
        });
    }

    protected processActive2(response: Response): Promise<FundDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FundDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FundDto[]>(null as any);
    }

    /**
     * @return OK
     */
    fundsGET(id: number): Promise<FundDto> {
        let url_ = this.baseUrl + "/api/Funds/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFundsGET(_response);
        });
    }

    protected processFundsGET(response: Response): Promise<FundDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FundDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FundDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    fundsPUT(id: number, body: UpdateFundDto | undefined): Promise<FundDto> {
        let url_ = this.baseUrl + "/api/Funds/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFundsPUT(_response);
        });
    }

    protected processFundsPUT(response: Response): Promise<FundDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FundDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FundDto>(null as any);
    }

    /**
     * @return OK
     */
    code(fundCode: string): Promise<FundDto> {
        let url_ = this.baseUrl + "/api/Funds/code/{fundCode}";
        if (fundCode === undefined || fundCode === null)
            throw new globalThis.Error("The parameter 'fundCode' must be defined.");
        url_ = url_.replace("{fundCode}", encodeURIComponent("" + fundCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCode(_response);
        });
    }

    protected processCode(response: Response): Promise<FundDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FundDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FundDto>(null as any);
    }

    /**
     * @return OK
     */
    balance(id: number, asOfDate: Date): Promise<FundBalanceDto> {
        let url_ = this.baseUrl + "/api/Funds/{id}/balance/{asOfDate}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (asOfDate === undefined || asOfDate === null)
            throw new globalThis.Error("The parameter 'asOfDate' must be defined.");
        url_ = url_.replace("{asOfDate}", encodeURIComponent(asOfDate ? "" + asOfDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBalance(_response);
        });
    }

    protected processBalance(response: Response): Promise<FundBalanceDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FundBalanceDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FundBalanceDto>(null as any);
    }

    /**
     * @return OK
     */
    balances(asOfDate: Date): Promise<FundBalanceDto[]> {
        let url_ = this.baseUrl + "/api/Funds/balances/{asOfDate}";
        if (asOfDate === undefined || asOfDate === null)
            throw new globalThis.Error("The parameter 'asOfDate' must be defined.");
        url_ = url_.replace("{asOfDate}", encodeURIComponent(asOfDate ? "" + asOfDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBalances(_response);
        });
    }

    protected processBalances(response: Response): Promise<FundBalanceDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FundBalanceDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FundBalanceDto[]>(null as any);
    }

    /**
     * @return OK
     */
    flatness(id: number, checkDate: Date): Promise<FundFlatnessCheckDto> {
        let url_ = this.baseUrl + "/api/Funds/{id}/flatness/{checkDate}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (checkDate === undefined || checkDate === null)
            throw new globalThis.Error("The parameter 'checkDate' must be defined.");
        url_ = url_.replace("{checkDate}", encodeURIComponent(checkDate ? "" + checkDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFlatness(_response);
        });
    }

    protected processFlatness(response: Response): Promise<FundFlatnessCheckDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FundFlatnessCheckDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FundFlatnessCheckDto>(null as any);
    }

    /**
     * @return OK
     */
    flatnessAll(checkDate: Date): Promise<FundFlatnessCheckDto[]> {
        let url_ = this.baseUrl + "/api/Funds/flatness/{checkDate}";
        if (checkDate === undefined || checkDate === null)
            throw new globalThis.Error("The parameter 'checkDate' must be defined.");
        url_ = url_.replace("{checkDate}", encodeURIComponent(checkDate ? "" + checkDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFlatnessAll(_response);
        });
    }

    protected processFlatnessAll(response: Response): Promise<FundFlatnessCheckDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FundFlatnessCheckDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FundFlatnessCheckDto[]>(null as any);
    }

    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return OK
     */
    cashflows(id: number, fromDate: Date | undefined, toDate: Date | undefined): Promise<CashflowDto[]> {
        let url_ = this.baseUrl + "/api/Funds/{id}/cashflows?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fromDate === null)
            throw new globalThis.Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new globalThis.Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCashflows(_response);
        });
    }

    protected processCashflows(response: Response): Promise<CashflowDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CashflowDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CashflowDto[]>(null as any);
    }

    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return OK
     */
    cashflowSummary(id: number, fromDate: Date | undefined, toDate: Date | undefined): Promise<FundCashflowSummaryDto> {
        let url_ = this.baseUrl + "/api/Funds/{id}/cashflow-summary?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fromDate === null)
            throw new globalThis.Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new globalThis.Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCashflowSummary(_response);
        });
    }

    protected processCashflowSummary(response: Response): Promise<FundCashflowSummaryDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FundCashflowSummaryDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FundCashflowSummaryDto>(null as any);
    }

    /**
     * @return OK
     */
    ensureFlatness(id: number, date: Date): Promise<void> {
        let url_ = this.baseUrl + "/api/Funds/{id}/ensure-flatness/{date}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (date === undefined || date === null)
            throw new globalThis.Error("The parameter 'date' must be defined.");
        url_ = url_.replace("{date}", encodeURIComponent(date ? "" + date.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnsureFlatness(_response);
        });
    }

    protected processEnsureFlatness(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    repoTradesAll(): Promise<RepoTradeDto[]> {
        let url_ = this.baseUrl + "/api/RepoTrades";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepoTradesAll(_response);
        });
    }

    protected processRepoTradesAll(response: Response): Promise<RepoTradeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoTradeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoTradeDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    repoTradesPOST(body: CreateRepoTradeDto | undefined): Promise<RepoTradeDto> {
        let url_ = this.baseUrl + "/api/RepoTrades";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepoTradesPOST(_response);
        });
    }

    protected processRepoTradesPOST(response: Response): Promise<RepoTradeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoTradeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoTradeDto>(null as any);
    }

    /**
     * @return OK
     */
    repoTradesGET(id: number): Promise<RepoTradeDto> {
        let url_ = this.baseUrl + "/api/RepoTrades/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepoTradesGET(_response);
        });
    }

    protected processRepoTradesGET(response: Response): Promise<RepoTradeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoTradeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoTradeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    repoTradesPUT(id: number, body: UpdateRepoTradeDto | undefined): Promise<RepoTradeDto> {
        let url_ = this.baseUrl + "/api/RepoTrades/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepoTradesPUT(_response);
        });
    }

    protected processRepoTradesPUT(response: Response): Promise<RepoTradeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoTradeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoTradeDto>(null as any);
    }

    /**
     * @return OK
     */
    repoTradesDELETE(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/RepoTrades/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepoTradesDELETE(_response);
        });
    }

    protected processRepoTradesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param fundId (optional) 
     * @param counterpartyId (optional) 
     * @param startDateFrom (optional) 
     * @param startDateTo (optional) 
     * @param settlementDate (optional) 
     * @param status (optional) 
     * @param direction (optional) 
     * @return OK
     */
    search(fundId: number | undefined, counterpartyId: number | undefined, startDateFrom: Date | undefined, startDateTo: Date | undefined, settlementDate: Date | undefined, status: string | undefined, direction: string | undefined): Promise<RepoTradeDto[]> {
        let url_ = this.baseUrl + "/api/RepoTrades/search?";
        if (fundId === null)
            throw new globalThis.Error("The parameter 'fundId' cannot be null.");
        else if (fundId !== undefined)
            url_ += "FundId=" + encodeURIComponent("" + fundId) + "&";
        if (counterpartyId === null)
            throw new globalThis.Error("The parameter 'counterpartyId' cannot be null.");
        else if (counterpartyId !== undefined)
            url_ += "CounterpartyId=" + encodeURIComponent("" + counterpartyId) + "&";
        if (startDateFrom === null)
            throw new globalThis.Error("The parameter 'startDateFrom' cannot be null.");
        else if (startDateFrom !== undefined)
            url_ += "StartDateFrom=" + encodeURIComponent(startDateFrom ? "" + startDateFrom.toISOString() : "") + "&";
        if (startDateTo === null)
            throw new globalThis.Error("The parameter 'startDateTo' cannot be null.");
        else if (startDateTo !== undefined)
            url_ += "StartDateTo=" + encodeURIComponent(startDateTo ? "" + startDateTo.toISOString() : "") + "&";
        if (settlementDate === null)
            throw new globalThis.Error("The parameter 'settlementDate' cannot be null.");
        else if (settlementDate !== undefined)
            url_ += "SettlementDate=" + encodeURIComponent(settlementDate ? "" + settlementDate.toISOString() : "") + "&";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (direction === null)
            throw new globalThis.Error("The parameter 'direction' cannot be null.");
        else if (direction !== undefined)
            url_ += "Direction=" + encodeURIComponent("" + direction) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<RepoTradeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoTradeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoTradeDto[]>(null as any);
    }

    /**
     * @return OK
     */
    fund(fundId: number): Promise<RepoTradeDto[]> {
        let url_ = this.baseUrl + "/api/RepoTrades/fund/{fundId}";
        if (fundId === undefined || fundId === null)
            throw new globalThis.Error("The parameter 'fundId' must be defined.");
        url_ = url_.replace("{fundId}", encodeURIComponent("" + fundId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFund(_response);
        });
    }

    protected processFund(response: Response): Promise<RepoTradeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoTradeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoTradeDto[]>(null as any);
    }

    /**
     * @return OK
     */
    active3(asOfDate: Date): Promise<RepoTradeDto[]> {
        let url_ = this.baseUrl + "/api/RepoTrades/active/{asOfDate}";
        if (asOfDate === undefined || asOfDate === null)
            throw new globalThis.Error("The parameter 'asOfDate' must be defined.");
        url_ = url_.replace("{asOfDate}", encodeURIComponent(asOfDate ? "" + asOfDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActive3(_response);
        });
    }

    protected processActive3(response: Response): Promise<RepoTradeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoTradeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoTradeDto[]>(null as any);
    }

    /**
     * @return OK
     */
    settlement(settlementDate: Date): Promise<RepoTradeDto[]> {
        let url_ = this.baseUrl + "/api/RepoTrades/settlement/{settlementDate}";
        if (settlementDate === undefined || settlementDate === null)
            throw new globalThis.Error("The parameter 'settlementDate' must be defined.");
        url_ = url_.replace("{settlementDate}", encodeURIComponent(settlementDate ? "" + settlementDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSettlement(_response);
        });
    }

    protected processSettlement(response: Response): Promise<RepoTradeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoTradeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoTradeDto[]>(null as any);
    }

    /**
     * @return OK
     */
    settle(id: number): Promise<RepoTradeDto> {
        let url_ = this.baseUrl + "/api/RepoTrades/{id}/settle";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSettle(_response);
        });
    }

    protected processSettle(response: Response): Promise<RepoTradeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoTradeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoTradeDto>(null as any);
    }

    /**
     * @return OK
     */
    mature(id: number): Promise<RepoTradeDto> {
        let url_ = this.baseUrl + "/api/RepoTrades/{id}/mature";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMature(_response);
        });
    }

    protected processMature(response: Response): Promise<RepoTradeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoTradeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoTradeDto>(null as any);
    }

    /**
     * @return OK
     */
    cancel(id: number): Promise<RepoTradeDto> {
        let url_ = this.baseUrl + "/api/RepoTrades/{id}/cancel";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancel(_response);
        });
    }

    protected processCancel(response: Response): Promise<RepoTradeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoTradeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoTradeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validate(body: CreateRepoTradeDto | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/RepoTrades/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidate(_response);
        });
    }

    protected processValidate(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param counterpartyId (optional) 
     * @param tradeDate (optional) 
     * @param proposedNotional (optional) 
     * @return OK
     */
    validateTargetCircle(counterpartyId: number | undefined, tradeDate: Date | undefined, proposedNotional: number | undefined): Promise<TargetCircleValidationDto> {
        let url_ = this.baseUrl + "/api/RepoTrades/validate-target-circle?";
        if (counterpartyId === null)
            throw new globalThis.Error("The parameter 'counterpartyId' cannot be null.");
        else if (counterpartyId !== undefined)
            url_ += "counterpartyId=" + encodeURIComponent("" + counterpartyId) + "&";
        if (tradeDate === null)
            throw new globalThis.Error("The parameter 'tradeDate' cannot be null.");
        else if (tradeDate !== undefined)
            url_ += "tradeDate=" + encodeURIComponent(tradeDate ? "" + tradeDate.toISOString() : "") + "&";
        if (proposedNotional === null)
            throw new globalThis.Error("The parameter 'proposedNotional' cannot be null.");
        else if (proposedNotional !== undefined)
            url_ += "proposedNotional=" + encodeURIComponent("" + proposedNotional) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateTargetCircle(_response);
        });
    }

    protected processValidateTargetCircle(response: Response): Promise<TargetCircleValidationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TargetCircleValidationDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TargetCircleValidationDto>(null as any);
    }

    /**
     * @return OK
     */
    getWeatherForecast(): Promise<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWeatherForecast(_response);
        });
    }

    protected processGetWeatherForecast(response: Response): Promise<WeatherForecast[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WeatherForecast[]>(null as any);
    }
}

export class AuthenticationRequest implements IAuthenticationRequest {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: IAuthenticationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IAuthenticationRequest {
    email?: string | undefined;
    password?: string | undefined;
}

export class AuthenticationResponse implements IAuthenticationResponse {
    token?: string | undefined;
    email?: string | undefined;
    displayName?: string | undefined;

    constructor(data?: IAuthenticationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.email = _data["email"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AuthenticationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["email"] = this.email;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAuthenticationResponse {
    token?: string | undefined;
    email?: string | undefined;
    displayName?: string | undefined;
}

export class CashflowDto implements ICashflowDto {
    id?: number;
    cashAccountId?: number;
    accountNumber?: string | undefined;
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    repoTradeId?: number | undefined;
    tradeReference?: string | undefined;
    amount?: number;
    currencyCode?: string | undefined;
    effectiveDate?: Date;
    description?: string | undefined;
    source?: string | undefined;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: ICashflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cashAccountId = _data["cashAccountId"];
            this.accountNumber = _data["accountNumber"];
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.repoTradeId = _data["repoTradeId"];
            this.tradeReference = _data["tradeReference"];
            this.amount = _data["amount"];
            this.currencyCode = _data["currencyCode"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : undefined as any;
            this.description = _data["description"];
            this.source = _data["source"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): CashflowDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cashAccountId"] = this.cashAccountId;
        data["accountNumber"] = this.accountNumber;
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["repoTradeId"] = this.repoTradeId;
        data["tradeReference"] = this.tradeReference;
        data["amount"] = this.amount;
        data["currencyCode"] = this.currencyCode;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : undefined as any;
        data["description"] = this.description;
        data["source"] = this.source;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface ICashflowDto {
    id?: number;
    cashAccountId?: number;
    accountNumber?: string | undefined;
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    repoTradeId?: number | undefined;
    tradeReference?: string | undefined;
    amount?: number;
    currencyCode?: string | undefined;
    effectiveDate?: Date;
    description?: string | undefined;
    source?: string | undefined;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class CounterpartyDto implements ICounterpartyDto {
    id?: number;
    name?: string | undefined;
    shortName?: string | undefined;
    country?: string | undefined;
    creditRating?: string | undefined;
    sector?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: ICounterpartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            this.country = _data["country"];
            this.creditRating = _data["creditRating"];
            this.sector = _data["sector"];
            this.isActive = _data["isActive"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): CounterpartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["country"] = this.country;
        data["creditRating"] = this.creditRating;
        data["sector"] = this.sector;
        data["isActive"] = this.isActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface ICounterpartyDto {
    id?: number;
    name?: string | undefined;
    shortName?: string | undefined;
    country?: string | undefined;
    creditRating?: string | undefined;
    sector?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class CounterpartyExposureDto implements ICounterpartyExposureDto {
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    tradeDate?: Date;
    currentExposure?: number;
    targetCircle?: number;
    availableLimit?: number;
    utilizationPercentage?: number;
    isLimitBreached?: boolean;

    constructor(data?: ICounterpartyExposureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.counterpartyId = _data["counterpartyId"];
            this.counterpartyName = _data["counterpartyName"];
            this.tradeDate = _data["tradeDate"] ? new Date(_data["tradeDate"].toString()) : undefined as any;
            this.currentExposure = _data["currentExposure"];
            this.targetCircle = _data["targetCircle"];
            this.availableLimit = _data["availableLimit"];
            this.utilizationPercentage = _data["utilizationPercentage"];
            this.isLimitBreached = _data["isLimitBreached"];
        }
    }

    static fromJS(data: any): CounterpartyExposureDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartyExposureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counterpartyId"] = this.counterpartyId;
        data["counterpartyName"] = this.counterpartyName;
        data["tradeDate"] = this.tradeDate ? this.tradeDate.toISOString() : undefined as any;
        data["currentExposure"] = this.currentExposure;
        data["targetCircle"] = this.targetCircle;
        data["availableLimit"] = this.availableLimit;
        data["utilizationPercentage"] = this.utilizationPercentage;
        data["isLimitBreached"] = this.isLimitBreached;
        return data;
    }
}

export interface ICounterpartyExposureDto {
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    tradeDate?: Date;
    currentExposure?: number;
    targetCircle?: number;
    availableLimit?: number;
    utilizationPercentage?: number;
    isLimitBreached?: boolean;
}

export class CreateCounterpartyDto implements ICreateCounterpartyDto {
    name?: string | undefined;
    shortName?: string | undefined;
    country?: string | undefined;
    creditRating?: string | undefined;
    sector?: string | undefined;
    isActive?: boolean;
    createdByUserId?: number;

    constructor(data?: ICreateCounterpartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            this.country = _data["country"];
            this.creditRating = _data["creditRating"];
            this.sector = _data["sector"];
            this.isActive = _data["isActive"];
            this.createdByUserId = _data["createdByUserId"];
        }
    }

    static fromJS(data: any): CreateCounterpartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCounterpartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["country"] = this.country;
        data["creditRating"] = this.creditRating;
        data["sector"] = this.sector;
        data["isActive"] = this.isActive;
        data["createdByUserId"] = this.createdByUserId;
        return data;
    }
}

export interface ICreateCounterpartyDto {
    name?: string | undefined;
    shortName?: string | undefined;
    country?: string | undefined;
    creditRating?: string | undefined;
    sector?: string | undefined;
    isActive?: boolean;
    createdByUserId?: number;
}

export class CreateFundDto implements ICreateFundDto {
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    isActive?: boolean;
    createdByUserId?: number;

    constructor(data?: ICreateFundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.currencyCode = _data["currencyCode"];
            this.isActive = _data["isActive"];
            this.createdByUserId = _data["createdByUserId"];
        }
    }

    static fromJS(data: any): CreateFundDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["currencyCode"] = this.currencyCode;
        data["isActive"] = this.isActive;
        data["createdByUserId"] = this.createdByUserId;
        return data;
    }
}

export interface ICreateFundDto {
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    isActive?: boolean;
    createdByUserId?: number;
}

export class CreateRepoTradeDto implements ICreateRepoTradeDto {
    fundId?: number;
    counterpartyId?: number;
    securityId?: number;
    collateralTypeId?: number;
    direction?: string | undefined;
    notional?: number;
    rate?: number;
    startDate?: Date;
    endDate?: Date;
    settlementDate?: Date;
    currency?: string | undefined;
    haircut?: number | undefined;
    createdByUserId?: number;

    constructor(data?: ICreateRepoTradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundId = _data["fundId"];
            this.counterpartyId = _data["counterpartyId"];
            this.securityId = _data["securityId"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.direction = _data["direction"];
            this.notional = _data["notional"];
            this.rate = _data["rate"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : undefined as any;
            this.settlementDate = _data["settlementDate"] ? new Date(_data["settlementDate"].toString()) : undefined as any;
            this.currency = _data["currency"];
            this.haircut = _data["haircut"];
            this.createdByUserId = _data["createdByUserId"];
        }
    }

    static fromJS(data: any): CreateRepoTradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRepoTradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundId"] = this.fundId;
        data["counterpartyId"] = this.counterpartyId;
        data["securityId"] = this.securityId;
        data["collateralTypeId"] = this.collateralTypeId;
        data["direction"] = this.direction;
        data["notional"] = this.notional;
        data["rate"] = this.rate;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : undefined as any;
        data["settlementDate"] = this.settlementDate ? this.settlementDate.toISOString() : undefined as any;
        data["currency"] = this.currency;
        data["haircut"] = this.haircut;
        data["createdByUserId"] = this.createdByUserId;
        return data;
    }
}

export interface ICreateRepoTradeDto {
    fundId?: number;
    counterpartyId?: number;
    securityId?: number;
    collateralTypeId?: number;
    direction?: string | undefined;
    notional?: number;
    rate?: number;
    startDate?: Date;
    endDate?: Date;
    settlementDate?: Date;
    currency?: string | undefined;
    haircut?: number | undefined;
    createdByUserId?: number;
}

export class EagleCashBalanceDto implements IEagleCashBalanceDto {
    fundCode?: string | undefined;
    fundName?: string | undefined;
    openingBalance?: number;
    currency?: string | undefined;
    balanceDate?: Date;
    source?: string | undefined;

    constructor(data?: IEagleCashBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.openingBalance = _data["openingBalance"];
            this.currency = _data["currency"];
            this.balanceDate = _data["balanceDate"] ? new Date(_data["balanceDate"].toString()) : undefined as any;
            this.source = _data["source"];
        }
    }

    static fromJS(data: any): EagleCashBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new EagleCashBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["openingBalance"] = this.openingBalance;
        data["currency"] = this.currency;
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : undefined as any;
        data["source"] = this.source;
        return data;
    }
}

export interface IEagleCashBalanceDto {
    fundCode?: string | undefined;
    fundName?: string | undefined;
    openingBalance?: number;
    currency?: string | undefined;
    balanceDate?: Date;
    source?: string | undefined;
}

export class EagleExportRequestDto implements IEagleExportRequestDto {
    exportDate?: Date;
    exportedByUserId?: number;

    constructor(data?: IEagleExportRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exportDate = _data["exportDate"] ? new Date(_data["exportDate"].toString()) : undefined as any;
            this.exportedByUserId = _data["exportedByUserId"];
        }
    }

    static fromJS(data: any): EagleExportRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new EagleExportRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exportDate"] = this.exportDate ? this.exportDate.toISOString() : undefined as any;
        data["exportedByUserId"] = this.exportedByUserId;
        return data;
    }
}

export interface IEagleExportRequestDto {
    exportDate?: Date;
    exportedByUserId?: number;
}

export class EagleExportResponseDto implements IEagleExportResponseDto {
    success?: boolean;
    message?: string | undefined;
    fundBalances?: FundBalanceExportDto[] | undefined;
    exportDate?: Date;
    exportFilePath?: string | undefined;

    constructor(data?: IEagleExportResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            if (Array.isArray(_data["fundBalances"])) {
                this.fundBalances = [] as any;
                for (let item of _data["fundBalances"])
                    this.fundBalances!.push(FundBalanceExportDto.fromJS(item));
            }
            this.exportDate = _data["exportDate"] ? new Date(_data["exportDate"].toString()) : undefined as any;
            this.exportFilePath = _data["exportFilePath"];
        }
    }

    static fromJS(data: any): EagleExportResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EagleExportResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        if (Array.isArray(this.fundBalances)) {
            data["fundBalances"] = [];
            for (let item of this.fundBalances)
                data["fundBalances"].push(item ? item.toJSON() : undefined as any);
        }
        data["exportDate"] = this.exportDate ? this.exportDate.toISOString() : undefined as any;
        data["exportFilePath"] = this.exportFilePath;
        return data;
    }
}

export interface IEagleExportResponseDto {
    success?: boolean;
    message?: string | undefined;
    fundBalances?: FundBalanceExportDto[] | undefined;
    exportDate?: Date;
    exportFilePath?: string | undefined;
}

export class EagleImportRequestDto implements IEagleImportRequestDto {
    balanceDate?: Date;
    cashBalances?: EagleCashBalanceDto[] | undefined;
    importedByUserId?: number;

    constructor(data?: IEagleImportRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.balanceDate = _data["balanceDate"] ? new Date(_data["balanceDate"].toString()) : undefined as any;
            if (Array.isArray(_data["cashBalances"])) {
                this.cashBalances = [] as any;
                for (let item of _data["cashBalances"])
                    this.cashBalances!.push(EagleCashBalanceDto.fromJS(item));
            }
            this.importedByUserId = _data["importedByUserId"];
        }
    }

    static fromJS(data: any): EagleImportRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new EagleImportRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : undefined as any;
        if (Array.isArray(this.cashBalances)) {
            data["cashBalances"] = [];
            for (let item of this.cashBalances)
                data["cashBalances"].push(item ? item.toJSON() : undefined as any);
        }
        data["importedByUserId"] = this.importedByUserId;
        return data;
    }
}

export interface IEagleImportRequestDto {
    balanceDate?: Date;
    cashBalances?: EagleCashBalanceDto[] | undefined;
    importedByUserId?: number;
}

export class EagleImportResponseDto implements IEagleImportResponseDto {
    success?: boolean;
    message?: string | undefined;
    recordsProcessed?: number;
    recordsImported?: number;
    errors?: string[] | undefined;
    importDate?: Date;

    constructor(data?: IEagleImportResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.recordsProcessed = _data["recordsProcessed"];
            this.recordsImported = _data["recordsImported"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.importDate = _data["importDate"] ? new Date(_data["importDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): EagleImportResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EagleImportResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["recordsProcessed"] = this.recordsProcessed;
        data["recordsImported"] = this.recordsImported;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["importDate"] = this.importDate ? this.importDate.toISOString() : undefined as any;
        return data;
    }
}

export interface IEagleImportResponseDto {
    success?: boolean;
    message?: string | undefined;
    recordsProcessed?: number;
    recordsImported?: number;
    errors?: string[] | undefined;
    importDate?: Date;
}

export class FundBalanceDto implements IFundBalanceDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    availableCash?: number;
    openingBalance?: number | undefined;
    asOfDate?: Date;

    constructor(data?: IFundBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.currencyCode = _data["currencyCode"];
            this.availableCash = _data["availableCash"];
            this.openingBalance = _data["openingBalance"];
            this.asOfDate = _data["asOfDate"] ? new Date(_data["asOfDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): FundBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new FundBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["currencyCode"] = this.currencyCode;
        data["availableCash"] = this.availableCash;
        data["openingBalance"] = this.openingBalance;
        data["asOfDate"] = this.asOfDate ? this.asOfDate.toISOString() : undefined as any;
        return data;
    }
}

export interface IFundBalanceDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    availableCash?: number;
    openingBalance?: number | undefined;
    asOfDate?: Date;
}

export class FundBalanceExportDto implements IFundBalanceExportDto {
    fundCode?: string | undefined;
    fundName?: string | undefined;
    closingBalance?: number;
    currency?: string | undefined;
    balanceDate?: Date;
    isFlat?: boolean;

    constructor(data?: IFundBalanceExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.closingBalance = _data["closingBalance"];
            this.currency = _data["currency"];
            this.balanceDate = _data["balanceDate"] ? new Date(_data["balanceDate"].toString()) : undefined as any;
            this.isFlat = _data["isFlat"];
        }
    }

    static fromJS(data: any): FundBalanceExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new FundBalanceExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["closingBalance"] = this.closingBalance;
        data["currency"] = this.currency;
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : undefined as any;
        data["isFlat"] = this.isFlat;
        return data;
    }
}

export interface IFundBalanceExportDto {
    fundCode?: string | undefined;
    fundName?: string | undefined;
    closingBalance?: number;
    currency?: string | undefined;
    balanceDate?: Date;
    isFlat?: boolean;
}

export class FundCashflowSummaryDto implements IFundCashflowSummaryDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    totalInflows?: number;
    totalOutflows?: number;
    netCashflow?: number;
    dateFrom?: Date;
    dateTo?: Date;

    constructor(data?: IFundCashflowSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.currencyCode = _data["currencyCode"];
            this.totalInflows = _data["totalInflows"];
            this.totalOutflows = _data["totalOutflows"];
            this.netCashflow = _data["netCashflow"];
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : undefined as any;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): FundCashflowSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new FundCashflowSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["currencyCode"] = this.currencyCode;
        data["totalInflows"] = this.totalInflows;
        data["totalOutflows"] = this.totalOutflows;
        data["netCashflow"] = this.netCashflow;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : undefined as any;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : undefined as any;
        return data;
    }
}

export interface IFundCashflowSummaryDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    totalInflows?: number;
    totalOutflows?: number;
    netCashflow?: number;
    dateFrom?: Date;
    dateTo?: Date;
}

export class FundDto implements IFundDto {
    id?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: IFundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.currencyCode = _data["currencyCode"];
            this.isActive = _data["isActive"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): FundDto {
        data = typeof data === 'object' ? data : {};
        let result = new FundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["currencyCode"] = this.currencyCode;
        data["isActive"] = this.isActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface IFundDto {
    id?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class FundFlatnessCheckDto implements IFundFlatnessCheckDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currentBalance?: number;
    currency?: string | undefined;
    isFlat?: boolean;
    requiredAdjustment?: number;
    adjustmentType?: string | undefined;

    constructor(data?: IFundFlatnessCheckDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.currentBalance = _data["currentBalance"];
            this.currency = _data["currency"];
            this.isFlat = _data["isFlat"];
            this.requiredAdjustment = _data["requiredAdjustment"];
            this.adjustmentType = _data["adjustmentType"];
        }
    }

    static fromJS(data: any): FundFlatnessCheckDto {
        data = typeof data === 'object' ? data : {};
        let result = new FundFlatnessCheckDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["currentBalance"] = this.currentBalance;
        data["currency"] = this.currency;
        data["isFlat"] = this.isFlat;
        data["requiredAdjustment"] = this.requiredAdjustment;
        data["adjustmentType"] = this.adjustmentType;
        return data;
    }
}

export interface IFundFlatnessCheckDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currentBalance?: number;
    currency?: string | undefined;
    isFlat?: boolean;
    requiredAdjustment?: number;
    adjustmentType?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class RepoTradeDto implements IRepoTradeDto {
    id?: number;
    tradeReference?: string | undefined;
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    securityId?: number;
    securityIsin?: string | undefined;
    securityName?: string | undefined;
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    direction?: string | undefined;
    notional?: number;
    rate?: number;
    startDate?: Date;
    endDate?: Date;
    settlementDate?: Date;
    status?: string | undefined;
    currency?: string | undefined;
    haircut?: number | undefined;
    collateralValue?: number | undefined;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: IRepoTradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tradeReference = _data["tradeReference"];
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.counterpartyId = _data["counterpartyId"];
            this.counterpartyName = _data["counterpartyName"];
            this.securityId = _data["securityId"];
            this.securityIsin = _data["securityIsin"];
            this.securityName = _data["securityName"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.collateralTypeName = _data["collateralTypeName"];
            this.direction = _data["direction"];
            this.notional = _data["notional"];
            this.rate = _data["rate"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : undefined as any;
            this.settlementDate = _data["settlementDate"] ? new Date(_data["settlementDate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.currency = _data["currency"];
            this.haircut = _data["haircut"];
            this.collateralValue = _data["collateralValue"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): RepoTradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepoTradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tradeReference"] = this.tradeReference;
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["counterpartyId"] = this.counterpartyId;
        data["counterpartyName"] = this.counterpartyName;
        data["securityId"] = this.securityId;
        data["securityIsin"] = this.securityIsin;
        data["securityName"] = this.securityName;
        data["collateralTypeId"] = this.collateralTypeId;
        data["collateralTypeName"] = this.collateralTypeName;
        data["direction"] = this.direction;
        data["notional"] = this.notional;
        data["rate"] = this.rate;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : undefined as any;
        data["settlementDate"] = this.settlementDate ? this.settlementDate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["currency"] = this.currency;
        data["haircut"] = this.haircut;
        data["collateralValue"] = this.collateralValue;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface IRepoTradeDto {
    id?: number;
    tradeReference?: string | undefined;
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    securityId?: number;
    securityIsin?: string | undefined;
    securityName?: string | undefined;
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    direction?: string | undefined;
    notional?: number;
    rate?: number;
    startDate?: Date;
    endDate?: Date;
    settlementDate?: Date;
    status?: string | undefined;
    currency?: string | undefined;
    haircut?: number | undefined;
    collateralValue?: number | undefined;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class TargetCircleValidationDto implements ITargetCircleValidationDto {
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    tradeDate?: Date;
    currentExposure?: number;
    proposedNotional?: number;
    targetCircle?: number;
    newTotalExposure?: number;
    isWithinLimit?: boolean;
    limitUtilizationPercentage?: number;
    validationMessage?: string | undefined;

    constructor(data?: ITargetCircleValidationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.counterpartyId = _data["counterpartyId"];
            this.counterpartyName = _data["counterpartyName"];
            this.tradeDate = _data["tradeDate"] ? new Date(_data["tradeDate"].toString()) : undefined as any;
            this.currentExposure = _data["currentExposure"];
            this.proposedNotional = _data["proposedNotional"];
            this.targetCircle = _data["targetCircle"];
            this.newTotalExposure = _data["newTotalExposure"];
            this.isWithinLimit = _data["isWithinLimit"];
            this.limitUtilizationPercentage = _data["limitUtilizationPercentage"];
            this.validationMessage = _data["validationMessage"];
        }
    }

    static fromJS(data: any): TargetCircleValidationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TargetCircleValidationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counterpartyId"] = this.counterpartyId;
        data["counterpartyName"] = this.counterpartyName;
        data["tradeDate"] = this.tradeDate ? this.tradeDate.toISOString() : undefined as any;
        data["currentExposure"] = this.currentExposure;
        data["proposedNotional"] = this.proposedNotional;
        data["targetCircle"] = this.targetCircle;
        data["newTotalExposure"] = this.newTotalExposure;
        data["isWithinLimit"] = this.isWithinLimit;
        data["limitUtilizationPercentage"] = this.limitUtilizationPercentage;
        data["validationMessage"] = this.validationMessage;
        return data;
    }
}

export interface ITargetCircleValidationDto {
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    tradeDate?: Date;
    currentExposure?: number;
    proposedNotional?: number;
    targetCircle?: number;
    newTotalExposure?: number;
    isWithinLimit?: boolean;
    limitUtilizationPercentage?: number;
    validationMessage?: string | undefined;
}

export class UpdateCounterpartyDto implements IUpdateCounterpartyDto {
    id?: number;
    shortName?: string | undefined;
    country?: string | undefined;
    creditRating?: string | undefined;
    sector?: string | undefined;
    isActive?: boolean;
    modifiedByUserId?: number;

    constructor(data?: IUpdateCounterpartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.shortName = _data["shortName"];
            this.country = _data["country"];
            this.creditRating = _data["creditRating"];
            this.sector = _data["sector"];
            this.isActive = _data["isActive"];
            this.modifiedByUserId = _data["modifiedByUserId"];
        }
    }

    static fromJS(data: any): UpdateCounterpartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCounterpartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["shortName"] = this.shortName;
        data["country"] = this.country;
        data["creditRating"] = this.creditRating;
        data["sector"] = this.sector;
        data["isActive"] = this.isActive;
        data["modifiedByUserId"] = this.modifiedByUserId;
        return data;
    }
}

export interface IUpdateCounterpartyDto {
    id?: number;
    shortName?: string | undefined;
    country?: string | undefined;
    creditRating?: string | undefined;
    sector?: string | undefined;
    isActive?: boolean;
    modifiedByUserId?: number;
}

export class UpdateFundDto implements IUpdateFundDto {
    id?: number;
    fundName?: string | undefined;
    isActive?: boolean;
    modifiedByUserId?: number;

    constructor(data?: IUpdateFundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fundName = _data["fundName"];
            this.isActive = _data["isActive"];
            this.modifiedByUserId = _data["modifiedByUserId"];
        }
    }

    static fromJS(data: any): UpdateFundDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fundName"] = this.fundName;
        data["isActive"] = this.isActive;
        data["modifiedByUserId"] = this.modifiedByUserId;
        return data;
    }
}

export interface IUpdateFundDto {
    id?: number;
    fundName?: string | undefined;
    isActive?: boolean;
    modifiedByUserId?: number;
}

export class UpdateRepoTradeDto implements IUpdateRepoTradeDto {
    id?: number;
    notional?: number;
    rate?: number;
    startDate?: Date;
    endDate?: Date;
    settlementDate?: Date;
    haircut?: number | undefined;
    modifiedByUserId?: number;

    constructor(data?: IUpdateRepoTradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.notional = _data["notional"];
            this.rate = _data["rate"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : undefined as any;
            this.settlementDate = _data["settlementDate"] ? new Date(_data["settlementDate"].toString()) : undefined as any;
            this.haircut = _data["haircut"];
            this.modifiedByUserId = _data["modifiedByUserId"];
        }
    }

    static fromJS(data: any): UpdateRepoTradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRepoTradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["notional"] = this.notional;
        data["rate"] = this.rate;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : undefined as any;
        data["settlementDate"] = this.settlementDate ? this.settlementDate.toISOString() : undefined as any;
        data["haircut"] = this.haircut;
        data["modifiedByUserId"] = this.modifiedByUserId;
        return data;
    }
}

export interface IUpdateRepoTradeDto {
    id?: number;
    notional?: number;
    rate?: number;
    startDate?: Date;
    endDate?: Date;
    settlementDate?: Date;
    haircut?: number | undefined;
    modifiedByUserId?: number;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    readonly temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : undefined as any;
            this.temperatureC = _data["temperatureC"];
            (this as any).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? formatDate(this.date) : undefined as any;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}