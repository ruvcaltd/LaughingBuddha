//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAuthClient {
    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: AuthenticationRequest | undefined): Observable<AuthenticationResponse>;
}

@Injectable()
export class AuthClient implements IAuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: AuthenticationRequest | undefined): Observable<AuthenticationResponse> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticationResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticationResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthenticationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICollateralTypesClient {
    /**
     * @return OK
     */
    collateralTypesAll(): Observable<CollateralTypeDto[]>;
    /**
     * @return OK
     */
    active(): Observable<CollateralTypeDto[]>;
    /**
     * @return OK
     */
    collateralTypes(id: number): Observable<CollateralTypeDto>;
}

@Injectable()
export class CollateralTypesClient implements ICollateralTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    collateralTypesAll(): Observable<CollateralTypeDto[]> {
        let url_ = this.baseUrl + "/api/CollateralTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCollateralTypesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCollateralTypesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CollateralTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CollateralTypeDto[]>;
        }));
    }

    protected processCollateralTypesAll(response: HttpResponseBase): Observable<CollateralTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CollateralTypeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    active(): Observable<CollateralTypeDto[]> {
        let url_ = this.baseUrl + "/api/CollateralTypes/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CollateralTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CollateralTypeDto[]>;
        }));
    }

    protected processActive(response: HttpResponseBase): Observable<CollateralTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CollateralTypeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    collateralTypes(id: number): Observable<CollateralTypeDto> {
        let url_ = this.baseUrl + "/api/CollateralTypes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCollateralTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCollateralTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CollateralTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CollateralTypeDto>;
        }));
    }

    protected processCollateralTypes(response: HttpResponseBase): Observable<CollateralTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CollateralTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICounterpartiesClient {
    /**
     * @return OK
     */
    counterpartiesAll(): Observable<CounterpartyDto[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    counterpartiesPOST(body: CreateCounterpartyDto | undefined): Observable<CounterpartyDto>;
    /**
     * @return OK
     */
    active2(): Observable<CounterpartyDto[]>;
    /**
     * @return OK
     */
    counterpartiesGET(id: number): Observable<CounterpartyDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    counterpartiesPUT(id: number, body: UpdateCounterpartyDto | undefined): Observable<CounterpartyDto>;
    /**
     * @return OK
     */
    exposure(id: number, tradeDate: Date): Observable<CounterpartyExposureDto>;
    /**
     * @return OK
     */
    exposures(tradeDate: Date): Observable<CounterpartyExposureDto[]>;
    /**
     * @return OK
     */
    limitBreaches(tradeDate: Date): Observable<CounterpartyExposureDto[]>;
}

@Injectable()
export class CounterpartiesClient implements ICounterpartiesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    counterpartiesAll(): Observable<CounterpartyDto[]> {
        let url_ = this.baseUrl + "/api/Counterparties";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCounterpartiesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCounterpartiesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CounterpartyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CounterpartyDto[]>;
        }));
    }

    protected processCounterpartiesAll(response: HttpResponseBase): Observable<CounterpartyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CounterpartyDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    counterpartiesPOST(body: CreateCounterpartyDto | undefined): Observable<CounterpartyDto> {
        let url_ = this.baseUrl + "/api/Counterparties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCounterpartiesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCounterpartiesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CounterpartyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CounterpartyDto>;
        }));
    }

    protected processCounterpartiesPOST(response: HttpResponseBase): Observable<CounterpartyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CounterpartyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    active2(): Observable<CounterpartyDto[]> {
        let url_ = this.baseUrl + "/api/Counterparties/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActive2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActive2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CounterpartyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CounterpartyDto[]>;
        }));
    }

    protected processActive2(response: HttpResponseBase): Observable<CounterpartyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CounterpartyDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    counterpartiesGET(id: number): Observable<CounterpartyDto> {
        let url_ = this.baseUrl + "/api/Counterparties/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCounterpartiesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCounterpartiesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CounterpartyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CounterpartyDto>;
        }));
    }

    protected processCounterpartiesGET(response: HttpResponseBase): Observable<CounterpartyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CounterpartyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    counterpartiesPUT(id: number, body: UpdateCounterpartyDto | undefined): Observable<CounterpartyDto> {
        let url_ = this.baseUrl + "/api/Counterparties/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCounterpartiesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCounterpartiesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CounterpartyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CounterpartyDto>;
        }));
    }

    protected processCounterpartiesPUT(response: HttpResponseBase): Observable<CounterpartyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CounterpartyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    exposure(id: number, tradeDate: Date): Observable<CounterpartyExposureDto> {
        let url_ = this.baseUrl + "/api/Counterparties/{id}/exposure/{tradeDate}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (tradeDate === undefined || tradeDate === null)
            throw new globalThis.Error("The parameter 'tradeDate' must be defined.");
        url_ = url_.replace("{tradeDate}", encodeURIComponent(tradeDate ? "" + tradeDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExposure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExposure(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CounterpartyExposureDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CounterpartyExposureDto>;
        }));
    }

    protected processExposure(response: HttpResponseBase): Observable<CounterpartyExposureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CounterpartyExposureDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    exposures(tradeDate: Date): Observable<CounterpartyExposureDto[]> {
        let url_ = this.baseUrl + "/api/Counterparties/exposures/{tradeDate}";
        if (tradeDate === undefined || tradeDate === null)
            throw new globalThis.Error("The parameter 'tradeDate' must be defined.");
        url_ = url_.replace("{tradeDate}", encodeURIComponent(tradeDate ? "" + tradeDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExposures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExposures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CounterpartyExposureDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CounterpartyExposureDto[]>;
        }));
    }

    protected processExposures(response: HttpResponseBase): Observable<CounterpartyExposureDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CounterpartyExposureDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    limitBreaches(tradeDate: Date): Observable<CounterpartyExposureDto[]> {
        let url_ = this.baseUrl + "/api/Counterparties/limit-breaches/{tradeDate}";
        if (tradeDate === undefined || tradeDate === null)
            throw new globalThis.Error("The parameter 'tradeDate' must be defined.");
        url_ = url_.replace("{tradeDate}", encodeURIComponent(tradeDate ? "" + tradeDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLimitBreaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLimitBreaches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CounterpartyExposureDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CounterpartyExposureDto[]>;
        }));
    }

    protected processLimitBreaches(response: HttpResponseBase): Observable<CounterpartyExposureDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CounterpartyExposureDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IEagleIntegrationClient {
    /**
     * @param body (optional) 
     * @return OK
     */
    importCashBalances(body: EagleImportRequestDto | undefined): Observable<EagleImportResponseDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    exportEndOfDayBalances(body: EagleExportRequestDto | undefined): Observable<EagleExportResponseDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    generateFlatFundBalances(body: EagleExportRequestDto | undefined): Observable<EagleExportResponseDto>;
    /**
     * @return OK
     */
    prepareEndOfDayBalances(exportDate: Date): Observable<FundBalanceExportDto[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    validateImportData(body: EagleImportRequestDto | undefined): Observable<boolean>;
    /**
     * @param fundCode (optional) 
     * @param openingBalance (optional) 
     * @param currency (optional) 
     * @param balanceDate (optional) 
     * @return OK
     */
    processCashBalance(fundCode: string | undefined, openingBalance: number | undefined, currency: string | undefined, balanceDate: Date | undefined): Observable<boolean>;
}

@Injectable()
export class EagleIntegrationClient implements IEagleIntegrationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    importCashBalances(body: EagleImportRequestDto | undefined): Observable<EagleImportResponseDto> {
        let url_ = this.baseUrl + "/api/EagleIntegration/import-cash-balances";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportCashBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportCashBalances(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EagleImportResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EagleImportResponseDto>;
        }));
    }

    protected processImportCashBalances(response: HttpResponseBase): Observable<EagleImportResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EagleImportResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    exportEndOfDayBalances(body: EagleExportRequestDto | undefined): Observable<EagleExportResponseDto> {
        let url_ = this.baseUrl + "/api/EagleIntegration/export-end-of-day-balances";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportEndOfDayBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportEndOfDayBalances(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EagleExportResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EagleExportResponseDto>;
        }));
    }

    protected processExportEndOfDayBalances(response: HttpResponseBase): Observable<EagleExportResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EagleExportResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    generateFlatFundBalances(body: EagleExportRequestDto | undefined): Observable<EagleExportResponseDto> {
        let url_ = this.baseUrl + "/api/EagleIntegration/generate-flat-fund-balances";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateFlatFundBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateFlatFundBalances(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EagleExportResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EagleExportResponseDto>;
        }));
    }

    protected processGenerateFlatFundBalances(response: HttpResponseBase): Observable<EagleExportResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EagleExportResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    prepareEndOfDayBalances(exportDate: Date): Observable<FundBalanceExportDto[]> {
        let url_ = this.baseUrl + "/api/EagleIntegration/prepare-end-of-day-balances/{exportDate}";
        if (exportDate === undefined || exportDate === null)
            throw new globalThis.Error("The parameter 'exportDate' must be defined.");
        url_ = url_.replace("{exportDate}", encodeURIComponent(exportDate ? "" + exportDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareEndOfDayBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareEndOfDayBalances(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FundBalanceExportDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FundBalanceExportDto[]>;
        }));
    }

    protected processPrepareEndOfDayBalances(response: HttpResponseBase): Observable<FundBalanceExportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FundBalanceExportDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validateImportData(body: EagleImportRequestDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/EagleIntegration/validate-import-data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateImportData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateImportData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processValidateImportData(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param fundCode (optional) 
     * @param openingBalance (optional) 
     * @param currency (optional) 
     * @param balanceDate (optional) 
     * @return OK
     */
    processCashBalance(fundCode: string | undefined, openingBalance: number | undefined, currency: string | undefined, balanceDate: Date | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/EagleIntegration/process-cash-balance?";
        if (fundCode === null)
            throw new globalThis.Error("The parameter 'fundCode' cannot be null.");
        else if (fundCode !== undefined)
            url_ += "fundCode=" + encodeURIComponent("" + fundCode) + "&";
        if (openingBalance === null)
            throw new globalThis.Error("The parameter 'openingBalance' cannot be null.");
        else if (openingBalance !== undefined)
            url_ += "openingBalance=" + encodeURIComponent("" + openingBalance) + "&";
        if (currency === null)
            throw new globalThis.Error("The parameter 'currency' cannot be null.");
        else if (currency !== undefined)
            url_ += "currency=" + encodeURIComponent("" + currency) + "&";
        if (balanceDate === null)
            throw new globalThis.Error("The parameter 'balanceDate' cannot be null.");
        else if (balanceDate !== undefined)
            url_ += "balanceDate=" + encodeURIComponent(balanceDate ? "" + balanceDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessCashBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessCashBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProcessCashBalance(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFundsClient {
    /**
     * @return OK
     */
    fundsAll(): Observable<FundDto[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    fundsPOST(body: CreateFundDto | undefined): Observable<FundDto>;
    /**
     * @return OK
     */
    active3(): Observable<FundDto[]>;
    /**
     * @return OK
     */
    fundsGET(id: number): Observable<FundDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    fundsPUT(id: number, body: UpdateFundDto | undefined): Observable<FundDto>;
    /**
     * @return OK
     */
    code(fundCode: string): Observable<FundDto>;
    /**
     * @return OK
     */
    balance(id: number, asOfDate: Date): Observable<FundBalanceDto>;
    /**
     * @return OK
     */
    balances(asOfDate: Date): Observable<FundBalanceDto[]>;
    /**
     * @return OK
     */
    flatness(id: number, checkDate: Date): Observable<FundFlatnessCheckDto>;
    /**
     * @return OK
     */
    flatnessAll(checkDate: Date): Observable<FundFlatnessCheckDto[]>;
    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return OK
     */
    cashflows(id: number, fromDate: Date | undefined, toDate: Date | undefined): Observable<CashflowDto[]>;
    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return OK
     */
    cashflowSummary(id: number, fromDate: Date | undefined, toDate: Date | undefined): Observable<FundCashflowSummaryDto>;
    /**
     * @return OK
     */
    ensureFlatness(id: number, date: Date): Observable<void>;
}

@Injectable()
export class FundsClient implements IFundsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    fundsAll(): Observable<FundDto[]> {
        let url_ = this.baseUrl + "/api/Funds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFundsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFundsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FundDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FundDto[]>;
        }));
    }

    protected processFundsAll(response: HttpResponseBase): Observable<FundDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FundDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    fundsPOST(body: CreateFundDto | undefined): Observable<FundDto> {
        let url_ = this.baseUrl + "/api/Funds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFundsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFundsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FundDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FundDto>;
        }));
    }

    protected processFundsPOST(response: HttpResponseBase): Observable<FundDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FundDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    active3(): Observable<FundDto[]> {
        let url_ = this.baseUrl + "/api/Funds/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActive3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActive3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FundDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FundDto[]>;
        }));
    }

    protected processActive3(response: HttpResponseBase): Observable<FundDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FundDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    fundsGET(id: number): Observable<FundDto> {
        let url_ = this.baseUrl + "/api/Funds/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFundsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFundsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FundDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FundDto>;
        }));
    }

    protected processFundsGET(response: HttpResponseBase): Observable<FundDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FundDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    fundsPUT(id: number, body: UpdateFundDto | undefined): Observable<FundDto> {
        let url_ = this.baseUrl + "/api/Funds/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFundsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFundsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FundDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FundDto>;
        }));
    }

    protected processFundsPUT(response: HttpResponseBase): Observable<FundDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FundDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    code(fundCode: string): Observable<FundDto> {
        let url_ = this.baseUrl + "/api/Funds/code/{fundCode}";
        if (fundCode === undefined || fundCode === null)
            throw new globalThis.Error("The parameter 'fundCode' must be defined.");
        url_ = url_.replace("{fundCode}", encodeURIComponent("" + fundCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FundDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FundDto>;
        }));
    }

    protected processCode(response: HttpResponseBase): Observable<FundDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FundDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    balance(id: number, asOfDate: Date): Observable<FundBalanceDto> {
        let url_ = this.baseUrl + "/api/Funds/{id}/balance/{asOfDate}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (asOfDate === undefined || asOfDate === null)
            throw new globalThis.Error("The parameter 'asOfDate' must be defined.");
        url_ = url_.replace("{asOfDate}", encodeURIComponent(asOfDate ? "" + asOfDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FundBalanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FundBalanceDto>;
        }));
    }

    protected processBalance(response: HttpResponseBase): Observable<FundBalanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FundBalanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    balances(asOfDate: Date): Observable<FundBalanceDto[]> {
        let url_ = this.baseUrl + "/api/Funds/balances/{asOfDate}";
        if (asOfDate === undefined || asOfDate === null)
            throw new globalThis.Error("The parameter 'asOfDate' must be defined.");
        url_ = url_.replace("{asOfDate}", encodeURIComponent(asOfDate ? "" + asOfDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalances(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FundBalanceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FundBalanceDto[]>;
        }));
    }

    protected processBalances(response: HttpResponseBase): Observable<FundBalanceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FundBalanceDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    flatness(id: number, checkDate: Date): Observable<FundFlatnessCheckDto> {
        let url_ = this.baseUrl + "/api/Funds/{id}/flatness/{checkDate}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (checkDate === undefined || checkDate === null)
            throw new globalThis.Error("The parameter 'checkDate' must be defined.");
        url_ = url_.replace("{checkDate}", encodeURIComponent(checkDate ? "" + checkDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFlatness(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFlatness(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FundFlatnessCheckDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FundFlatnessCheckDto>;
        }));
    }

    protected processFlatness(response: HttpResponseBase): Observable<FundFlatnessCheckDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FundFlatnessCheckDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    flatnessAll(checkDate: Date): Observable<FundFlatnessCheckDto[]> {
        let url_ = this.baseUrl + "/api/Funds/flatness/{checkDate}";
        if (checkDate === undefined || checkDate === null)
            throw new globalThis.Error("The parameter 'checkDate' must be defined.");
        url_ = url_.replace("{checkDate}", encodeURIComponent(checkDate ? "" + checkDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFlatnessAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFlatnessAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FundFlatnessCheckDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FundFlatnessCheckDto[]>;
        }));
    }

    protected processFlatnessAll(response: HttpResponseBase): Observable<FundFlatnessCheckDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FundFlatnessCheckDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return OK
     */
    cashflows(id: number, fromDate: Date | undefined, toDate: Date | undefined): Observable<CashflowDto[]> {
        let url_ = this.baseUrl + "/api/Funds/{id}/cashflows?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fromDate === null)
            throw new globalThis.Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new globalThis.Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCashflows(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCashflows(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CashflowDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CashflowDto[]>;
        }));
    }

    protected processCashflows(response: HttpResponseBase): Observable<CashflowDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CashflowDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return OK
     */
    cashflowSummary(id: number, fromDate: Date | undefined, toDate: Date | undefined): Observable<FundCashflowSummaryDto> {
        let url_ = this.baseUrl + "/api/Funds/{id}/cashflow-summary?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fromDate === null)
            throw new globalThis.Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new globalThis.Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCashflowSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCashflowSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FundCashflowSummaryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FundCashflowSummaryDto>;
        }));
    }

    protected processCashflowSummary(response: HttpResponseBase): Observable<FundCashflowSummaryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FundCashflowSummaryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    ensureFlatness(id: number, date: Date): Observable<void> {
        let url_ = this.baseUrl + "/api/Funds/{id}/ensure-flatness/{date}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (date === undefined || date === null)
            throw new globalThis.Error("The parameter 'date' must be defined.");
        url_ = url_.replace("{date}", encodeURIComponent(date ? "" + date.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnsureFlatness(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnsureFlatness(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnsureFlatness(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRepoRatesClient {
    /**
     * @return OK
     */
    repoRatesGET(id: number): Observable<RepoRateDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    repoRatesPUT(id: number, body: UpdateRepoRateDto | undefined): Observable<RepoRateDto>;
    /**
     * @return OK
     */
    date(repoDate: Date): Observable<RepoRateDto[]>;
    /**
     * @return OK
     */
    counterparty(counterpartyId: number): Observable<RepoRateDto[]>;
    /**
     * @param currentDate (optional) 
     * @return OK
     */
    previousDay(currentDate: Date | undefined): Observable<PreviousDayRepoRateDto[]>;
    /**
     * @param body (optional) 
     * @return Created
     */
    repoRatesPOST(body: CreateRepoRateDto | undefined): Observable<RepoRateDto>;
    /**
     * @return OK
     */
    setInactive(id: number): Observable<RepoRateDto>;
    /**
     * @return OK
     */
    setActive(id: number): Observable<RepoRateDto>;
    /**
     * @return OK
     */
    active4(asOfDate: Date): Observable<RepoRateDto[]>;
    /**
     * @param counterpartyId (optional) 
     * @param collateralTypeId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param activeOnly (optional) 
     * @return OK
     */
    search(counterpartyId: number | undefined, collateralTypeId: number | undefined, fromDate: Date | undefined, toDate: Date | undefined, activeOnly: boolean | undefined): Observable<RepoRateDto[]>;
}

@Injectable()
export class RepoRatesClient implements IRepoRatesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    repoRatesGET(id: number): Observable<RepoRateDto> {
        let url_ = this.baseUrl + "/api/RepoRates/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRepoRatesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepoRatesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoRateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoRateDto>;
        }));
    }

    protected processRepoRatesGET(response: HttpResponseBase): Observable<RepoRateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoRateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    repoRatesPUT(id: number, body: UpdateRepoRateDto | undefined): Observable<RepoRateDto> {
        let url_ = this.baseUrl + "/api/RepoRates/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRepoRatesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepoRatesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoRateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoRateDto>;
        }));
    }

    protected processRepoRatesPUT(response: HttpResponseBase): Observable<RepoRateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoRateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    date(repoDate: Date): Observable<RepoRateDto[]> {
        let url_ = this.baseUrl + "/api/RepoRates/date/{repoDate}";
        if (repoDate === undefined || repoDate === null)
            throw new globalThis.Error("The parameter 'repoDate' must be defined.");
        url_ = url_.replace("{repoDate}", encodeURIComponent(repoDate ? "" + repoDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoRateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoRateDto[]>;
        }));
    }

    protected processDate(response: HttpResponseBase): Observable<RepoRateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoRateDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    counterparty(counterpartyId: number): Observable<RepoRateDto[]> {
        let url_ = this.baseUrl + "/api/RepoRates/counterparty/{counterpartyId}";
        if (counterpartyId === undefined || counterpartyId === null)
            throw new globalThis.Error("The parameter 'counterpartyId' must be defined.");
        url_ = url_.replace("{counterpartyId}", encodeURIComponent("" + counterpartyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCounterparty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCounterparty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoRateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoRateDto[]>;
        }));
    }

    protected processCounterparty(response: HttpResponseBase): Observable<RepoRateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoRateDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentDate (optional) 
     * @return OK
     */
    previousDay(currentDate: Date | undefined): Observable<PreviousDayRepoRateDto[]> {
        let url_ = this.baseUrl + "/api/RepoRates/previous-day?";
        if (currentDate === null)
            throw new globalThis.Error("The parameter 'currentDate' cannot be null.");
        else if (currentDate !== undefined)
            url_ += "currentDate=" + encodeURIComponent(currentDate ? "" + currentDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreviousDay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreviousDay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PreviousDayRepoRateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PreviousDayRepoRateDto[]>;
        }));
    }

    protected processPreviousDay(response: HttpResponseBase): Observable<PreviousDayRepoRateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PreviousDayRepoRateDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    repoRatesPOST(body: CreateRepoRateDto | undefined): Observable<RepoRateDto> {
        let url_ = this.baseUrl + "/api/RepoRates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRepoRatesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepoRatesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoRateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoRateDto>;
        }));
    }

    protected processRepoRatesPOST(response: HttpResponseBase): Observable<RepoRateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = RepoRateDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    setInactive(id: number): Observable<RepoRateDto> {
        let url_ = this.baseUrl + "/api/RepoRates/{id}/set-inactive";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetInactive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetInactive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoRateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoRateDto>;
        }));
    }

    protected processSetInactive(response: HttpResponseBase): Observable<RepoRateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoRateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    setActive(id: number): Observable<RepoRateDto> {
        let url_ = this.baseUrl + "/api/RepoRates/{id}/set-active";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoRateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoRateDto>;
        }));
    }

    protected processSetActive(response: HttpResponseBase): Observable<RepoRateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoRateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    active4(asOfDate: Date): Observable<RepoRateDto[]> {
        let url_ = this.baseUrl + "/api/RepoRates/active/{asOfDate}";
        if (asOfDate === undefined || asOfDate === null)
            throw new globalThis.Error("The parameter 'asOfDate' must be defined.");
        url_ = url_.replace("{asOfDate}", encodeURIComponent(asOfDate ? "" + asOfDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActive4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActive4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoRateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoRateDto[]>;
        }));
    }

    protected processActive4(response: HttpResponseBase): Observable<RepoRateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoRateDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param counterpartyId (optional) 
     * @param collateralTypeId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param activeOnly (optional) 
     * @return OK
     */
    search(counterpartyId: number | undefined, collateralTypeId: number | undefined, fromDate: Date | undefined, toDate: Date | undefined, activeOnly: boolean | undefined): Observable<RepoRateDto[]> {
        let url_ = this.baseUrl + "/api/RepoRates/search?";
        if (counterpartyId === null)
            throw new globalThis.Error("The parameter 'counterpartyId' cannot be null.");
        else if (counterpartyId !== undefined)
            url_ += "counterpartyId=" + encodeURIComponent("" + counterpartyId) + "&";
        if (collateralTypeId === null)
            throw new globalThis.Error("The parameter 'collateralTypeId' cannot be null.");
        else if (collateralTypeId !== undefined)
            url_ += "collateralTypeId=" + encodeURIComponent("" + collateralTypeId) + "&";
        if (fromDate === null)
            throw new globalThis.Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new globalThis.Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (activeOnly === null)
            throw new globalThis.Error("The parameter 'activeOnly' cannot be null.");
        else if (activeOnly !== undefined)
            url_ += "activeOnly=" + encodeURIComponent("" + activeOnly) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoRateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoRateDto[]>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<RepoRateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoRateDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRepoTradesClient {
    /**
     * @return OK
     */
    repoTradesAll(): Observable<RepoTradeDto[]>;
    /**
     * @param body (optional) 
     * @return Created
     */
    repoTradesPOST(body: CreateRepoTradeDto | undefined): Observable<RepoRateDto>;
    /**
     * @return OK
     */
    repoTradesGET(id: number): Observable<RepoTradeDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    repoTradesPUT(id: number, body: UpdateRepoTradeDto | undefined): Observable<RepoTradeDto>;
    /**
     * @return OK
     */
    repoTradesDELETE(id: number): Observable<void>;
    /**
     * @param fundId (optional) 
     * @param counterpartyId (optional) 
     * @param startDateFrom (optional) 
     * @param startDateTo (optional) 
     * @param settlementDate (optional) 
     * @param status (optional) 
     * @param direction (optional) 
     * @return OK
     */
    search2(fundId: number | undefined, counterpartyId: number | undefined, startDateFrom: Date | undefined, startDateTo: Date | undefined, settlementDate: Date | undefined, status: string | undefined, direction: string | undefined): Observable<RepoTradeDto[]>;
    /**
     * @return OK
     */
    fund(fundId: number): Observable<RepoTradeDto[]>;
    /**
     * @return OK
     */
    active5(asOfDate: Date): Observable<RepoTradeDto[]>;
    /**
     * @return OK
     */
    settlement(settlementDate: Date): Observable<RepoTradeDto[]>;
    /**
     * @return OK
     */
    settle(id: number): Observable<RepoTradeDto>;
    /**
     * @return OK
     */
    mature(id: number): Observable<RepoTradeDto>;
    /**
     * @return OK
     */
    cancel(id: number): Observable<RepoTradeDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    validate(body: CreateRepoTradeDto | undefined): Observable<boolean>;
    /**
     * @param counterpartyId (optional) 
     * @param tradeDate (optional) 
     * @param proposedNotional (optional) 
     * @return OK
     */
    validateTargetCircle(counterpartyId: number | undefined, tradeDate: Date | undefined, proposedNotional: number | undefined): Observable<TargetCircleValidationDto>;
}

@Injectable()
export class RepoTradesClient implements IRepoTradesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    repoTradesAll(): Observable<RepoTradeDto[]> {
        let url_ = this.baseUrl + "/api/RepoTrades";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRepoTradesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepoTradesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoTradeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoTradeDto[]>;
        }));
    }

    protected processRepoTradesAll(response: HttpResponseBase): Observable<RepoTradeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoTradeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    repoTradesPOST(body: CreateRepoTradeDto | undefined): Observable<RepoRateDto> {
        let url_ = this.baseUrl + "/api/RepoTrades";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRepoTradesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepoTradesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoRateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoRateDto>;
        }));
    }

    protected processRepoTradesPOST(response: HttpResponseBase): Observable<RepoRateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = RepoRateDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    repoTradesGET(id: number): Observable<RepoTradeDto> {
        let url_ = this.baseUrl + "/api/RepoTrades/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRepoTradesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepoTradesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoTradeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoTradeDto>;
        }));
    }

    protected processRepoTradesGET(response: HttpResponseBase): Observable<RepoTradeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoTradeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    repoTradesPUT(id: number, body: UpdateRepoTradeDto | undefined): Observable<RepoTradeDto> {
        let url_ = this.baseUrl + "/api/RepoTrades/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRepoTradesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepoTradesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoTradeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoTradeDto>;
        }));
    }

    protected processRepoTradesPUT(response: HttpResponseBase): Observable<RepoTradeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoTradeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    repoTradesDELETE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/RepoTrades/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRepoTradesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepoTradesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRepoTradesDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param fundId (optional) 
     * @param counterpartyId (optional) 
     * @param startDateFrom (optional) 
     * @param startDateTo (optional) 
     * @param settlementDate (optional) 
     * @param status (optional) 
     * @param direction (optional) 
     * @return OK
     */
    search2(fundId: number | undefined, counterpartyId: number | undefined, startDateFrom: Date | undefined, startDateTo: Date | undefined, settlementDate: Date | undefined, status: string | undefined, direction: string | undefined): Observable<RepoTradeDto[]> {
        let url_ = this.baseUrl + "/api/RepoTrades/search?";
        if (fundId === null)
            throw new globalThis.Error("The parameter 'fundId' cannot be null.");
        else if (fundId !== undefined)
            url_ += "FundId=" + encodeURIComponent("" + fundId) + "&";
        if (counterpartyId === null)
            throw new globalThis.Error("The parameter 'counterpartyId' cannot be null.");
        else if (counterpartyId !== undefined)
            url_ += "CounterpartyId=" + encodeURIComponent("" + counterpartyId) + "&";
        if (startDateFrom === null)
            throw new globalThis.Error("The parameter 'startDateFrom' cannot be null.");
        else if (startDateFrom !== undefined)
            url_ += "StartDateFrom=" + encodeURIComponent(startDateFrom ? "" + startDateFrom.toISOString() : "") + "&";
        if (startDateTo === null)
            throw new globalThis.Error("The parameter 'startDateTo' cannot be null.");
        else if (startDateTo !== undefined)
            url_ += "StartDateTo=" + encodeURIComponent(startDateTo ? "" + startDateTo.toISOString() : "") + "&";
        if (settlementDate === null)
            throw new globalThis.Error("The parameter 'settlementDate' cannot be null.");
        else if (settlementDate !== undefined)
            url_ += "SettlementDate=" + encodeURIComponent(settlementDate ? "" + settlementDate.toISOString() : "") + "&";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (direction === null)
            throw new globalThis.Error("The parameter 'direction' cannot be null.");
        else if (direction !== undefined)
            url_ += "Direction=" + encodeURIComponent("" + direction) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoTradeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoTradeDto[]>;
        }));
    }

    protected processSearch2(response: HttpResponseBase): Observable<RepoTradeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoTradeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    fund(fundId: number): Observable<RepoTradeDto[]> {
        let url_ = this.baseUrl + "/api/RepoTrades/fund/{fundId}";
        if (fundId === undefined || fundId === null)
            throw new globalThis.Error("The parameter 'fundId' must be defined.");
        url_ = url_.replace("{fundId}", encodeURIComponent("" + fundId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFund(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFund(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoTradeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoTradeDto[]>;
        }));
    }

    protected processFund(response: HttpResponseBase): Observable<RepoTradeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoTradeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    active5(asOfDate: Date): Observable<RepoTradeDto[]> {
        let url_ = this.baseUrl + "/api/RepoTrades/active/{asOfDate}";
        if (asOfDate === undefined || asOfDate === null)
            throw new globalThis.Error("The parameter 'asOfDate' must be defined.");
        url_ = url_.replace("{asOfDate}", encodeURIComponent(asOfDate ? "" + asOfDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActive5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActive5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoTradeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoTradeDto[]>;
        }));
    }

    protected processActive5(response: HttpResponseBase): Observable<RepoTradeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoTradeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    settlement(settlementDate: Date): Observable<RepoTradeDto[]> {
        let url_ = this.baseUrl + "/api/RepoTrades/settlement/{settlementDate}";
        if (settlementDate === undefined || settlementDate === null)
            throw new globalThis.Error("The parameter 'settlementDate' must be defined.");
        url_ = url_.replace("{settlementDate}", encodeURIComponent(settlementDate ? "" + settlementDate.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSettlement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSettlement(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoTradeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoTradeDto[]>;
        }));
    }

    protected processSettlement(response: HttpResponseBase): Observable<RepoTradeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepoTradeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    settle(id: number): Observable<RepoTradeDto> {
        let url_ = this.baseUrl + "/api/RepoTrades/{id}/settle";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSettle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSettle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoTradeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoTradeDto>;
        }));
    }

    protected processSettle(response: HttpResponseBase): Observable<RepoTradeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoTradeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    mature(id: number): Observable<RepoTradeDto> {
        let url_ = this.baseUrl + "/api/RepoTrades/{id}/mature";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMature(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoTradeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoTradeDto>;
        }));
    }

    protected processMature(response: HttpResponseBase): Observable<RepoTradeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoTradeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    cancel(id: number): Observable<RepoTradeDto> {
        let url_ = this.baseUrl + "/api/RepoTrades/{id}/cancel";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RepoTradeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RepoTradeDto>;
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<RepoTradeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoTradeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validate(body: CreateRepoTradeDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/RepoTrades/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processValidate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param counterpartyId (optional) 
     * @param tradeDate (optional) 
     * @param proposedNotional (optional) 
     * @return OK
     */
    validateTargetCircle(counterpartyId: number | undefined, tradeDate: Date | undefined, proposedNotional: number | undefined): Observable<TargetCircleValidationDto> {
        let url_ = this.baseUrl + "/api/RepoTrades/validate-target-circle?";
        if (counterpartyId === null)
            throw new globalThis.Error("The parameter 'counterpartyId' cannot be null.");
        else if (counterpartyId !== undefined)
            url_ += "counterpartyId=" + encodeURIComponent("" + counterpartyId) + "&";
        if (tradeDate === null)
            throw new globalThis.Error("The parameter 'tradeDate' cannot be null.");
        else if (tradeDate !== undefined)
            url_ += "tradeDate=" + encodeURIComponent(tradeDate ? "" + tradeDate.toISOString() : "") + "&";
        if (proposedNotional === null)
            throw new globalThis.Error("The parameter 'proposedNotional' cannot be null.");
        else if (proposedNotional !== undefined)
            url_ += "proposedNotional=" + encodeURIComponent("" + proposedNotional) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateTargetCircle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateTargetCircle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TargetCircleValidationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TargetCircleValidationDto>;
        }));
    }

    protected processValidateTargetCircle(response: HttpResponseBase): Observable<TargetCircleValidationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TargetCircleValidationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherForecastClient {
    /**
     * @return OK
     */
    getWeatherForecast(): Observable<WeatherForecast[]>;
}

@Injectable()
export class WeatherForecastClient implements IWeatherForecastClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getWeatherForecast(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeatherForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeatherForecast(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;
        }));
    }

    protected processGetWeatherForecast(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AuthenticationRequest implements IAuthenticationRequest {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: IAuthenticationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IAuthenticationRequest {
    email?: string | undefined;
    password?: string | undefined;
}

export class AuthenticationResponse implements IAuthenticationResponse {
    userId?: number;
    token?: string | undefined;
    email?: string | undefined;
    displayName?: string | undefined;

    constructor(data?: IAuthenticationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.token = _data["token"];
            this.email = _data["email"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): AuthenticationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["token"] = this.token;
        data["email"] = this.email;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAuthenticationResponse {
    userId?: number;
    token?: string | undefined;
    email?: string | undefined;
    displayName?: string | undefined;
}

export class CashflowDto implements ICashflowDto {
    id?: number;
    cashAccountId?: number;
    accountNumber?: string | undefined;
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    repoTradeId?: number | undefined;
    tradeReference?: string | undefined;
    amount?: number;
    currencyCode?: string | undefined;
    effectiveDate?: Date;
    description?: string | undefined;
    source?: string | undefined;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: ICashflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cashAccountId = _data["cashAccountId"];
            this.accountNumber = _data["accountNumber"];
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.repoTradeId = _data["repoTradeId"];
            this.tradeReference = _data["tradeReference"];
            this.amount = _data["amount"];
            this.currencyCode = _data["currencyCode"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : undefined as any;
            this.description = _data["description"];
            this.source = _data["source"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): CashflowDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cashAccountId"] = this.cashAccountId;
        data["accountNumber"] = this.accountNumber;
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["repoTradeId"] = this.repoTradeId;
        data["tradeReference"] = this.tradeReference;
        data["amount"] = this.amount;
        data["currencyCode"] = this.currencyCode;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : undefined as any;
        data["description"] = this.description;
        data["source"] = this.source;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface ICashflowDto {
    id?: number;
    cashAccountId?: number;
    accountNumber?: string | undefined;
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    repoTradeId?: number | undefined;
    tradeReference?: string | undefined;
    amount?: number;
    currencyCode?: string | undefined;
    effectiveDate?: Date;
    description?: string | undefined;
    source?: string | undefined;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class CollateralTypeDto implements ICollateralTypeDto {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    standardHaircut?: number | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: ICollateralTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.standardHaircut = _data["standardHaircut"];
            this.isActive = _data["isActive"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): CollateralTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollateralTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["standardHaircut"] = this.standardHaircut;
        data["isActive"] = this.isActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface ICollateralTypeDto {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    standardHaircut?: number | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class CounterpartyDto implements ICounterpartyDto {
    id?: number;
    name?: string | undefined;
    shortName?: string | undefined;
    country?: string | undefined;
    creditRating?: string | undefined;
    sector?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: ICounterpartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            this.country = _data["country"];
            this.creditRating = _data["creditRating"];
            this.sector = _data["sector"];
            this.isActive = _data["isActive"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): CounterpartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["country"] = this.country;
        data["creditRating"] = this.creditRating;
        data["sector"] = this.sector;
        data["isActive"] = this.isActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface ICounterpartyDto {
    id?: number;
    name?: string | undefined;
    shortName?: string | undefined;
    country?: string | undefined;
    creditRating?: string | undefined;
    sector?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class CounterpartyExposureDto implements ICounterpartyExposureDto {
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    tradeDate?: Date;
    currentExposure?: number;
    targetCircle?: number;
    availableLimit?: number;
    utilizationPercentage?: number;
    isLimitBreached?: boolean;

    constructor(data?: ICounterpartyExposureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.counterpartyId = _data["counterpartyId"];
            this.counterpartyName = _data["counterpartyName"];
            this.tradeDate = _data["tradeDate"] ? new Date(_data["tradeDate"].toString()) : undefined as any;
            this.currentExposure = _data["currentExposure"];
            this.targetCircle = _data["targetCircle"];
            this.availableLimit = _data["availableLimit"];
            this.utilizationPercentage = _data["utilizationPercentage"];
            this.isLimitBreached = _data["isLimitBreached"];
        }
    }

    static fromJS(data: any): CounterpartyExposureDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartyExposureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counterpartyId"] = this.counterpartyId;
        data["counterpartyName"] = this.counterpartyName;
        data["tradeDate"] = this.tradeDate ? this.tradeDate.toISOString() : undefined as any;
        data["currentExposure"] = this.currentExposure;
        data["targetCircle"] = this.targetCircle;
        data["availableLimit"] = this.availableLimit;
        data["utilizationPercentage"] = this.utilizationPercentage;
        data["isLimitBreached"] = this.isLimitBreached;
        return data;
    }
}

export interface ICounterpartyExposureDto {
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    tradeDate?: Date;
    currentExposure?: number;
    targetCircle?: number;
    availableLimit?: number;
    utilizationPercentage?: number;
    isLimitBreached?: boolean;
}

export class CreateCounterpartyDto implements ICreateCounterpartyDto {
    name?: string | undefined;
    shortName?: string | undefined;
    country?: string | undefined;
    creditRating?: string | undefined;
    sector?: string | undefined;
    isActive?: boolean;
    createdByUserId?: number;

    constructor(data?: ICreateCounterpartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            this.country = _data["country"];
            this.creditRating = _data["creditRating"];
            this.sector = _data["sector"];
            this.isActive = _data["isActive"];
            this.createdByUserId = _data["createdByUserId"];
        }
    }

    static fromJS(data: any): CreateCounterpartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCounterpartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["country"] = this.country;
        data["creditRating"] = this.creditRating;
        data["sector"] = this.sector;
        data["isActive"] = this.isActive;
        data["createdByUserId"] = this.createdByUserId;
        return data;
    }
}

export interface ICreateCounterpartyDto {
    name?: string | undefined;
    shortName?: string | undefined;
    country?: string | undefined;
    creditRating?: string | undefined;
    sector?: string | undefined;
    isActive?: boolean;
    createdByUserId?: number;
}

export class CreateFundDto implements ICreateFundDto {
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    isActive?: boolean;
    createdByUserId?: number;

    constructor(data?: ICreateFundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.currencyCode = _data["currencyCode"];
            this.isActive = _data["isActive"];
            this.createdByUserId = _data["createdByUserId"];
        }
    }

    static fromJS(data: any): CreateFundDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["currencyCode"] = this.currencyCode;
        data["isActive"] = this.isActive;
        data["createdByUserId"] = this.createdByUserId;
        return data;
    }
}

export interface ICreateFundDto {
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    isActive?: boolean;
    createdByUserId?: number;
}

export class CreateRepoRateDto implements ICreateRepoRateDto {
    counterpartyId?: number;
    collateralTypeId?: number;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean;
    createdByUserId?: number;

    constructor(data?: ICreateRepoRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.counterpartyId = _data["counterpartyId"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.repoDate = _data["repoDate"] ? new Date(_data["repoDate"].toString()) : undefined as any;
            this.repoRate = _data["repoRate"];
            this.targetCircle = _data["targetCircle"];
            this.finalCircle = _data["finalCircle"];
            this.active = _data["active"];
            this.createdByUserId = _data["createdByUserId"];
        }
    }

    static fromJS(data: any): CreateRepoRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRepoRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counterpartyId"] = this.counterpartyId;
        data["collateralTypeId"] = this.collateralTypeId;
        data["repoDate"] = this.repoDate ? this.repoDate.toISOString() : undefined as any;
        data["repoRate"] = this.repoRate;
        data["targetCircle"] = this.targetCircle;
        data["finalCircle"] = this.finalCircle;
        data["active"] = this.active;
        data["createdByUserId"] = this.createdByUserId;
        return data;
    }
}

export interface ICreateRepoRateDto {
    counterpartyId?: number;
    collateralTypeId?: number;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean;
    createdByUserId?: number;
}

export class CreateRepoTradeDto implements ICreateRepoTradeDto {
    fundId?: number;
    counterpartyId?: number;
    securityId?: number;
    collateralTypeId?: number;
    direction?: string | undefined;
    notional?: number;
    rate?: number;
    startDate?: Date;
    endDate?: Date;
    settlementDate?: Date;
    currency?: string | undefined;
    haircut?: number | undefined;
    createdByUserId?: number;

    constructor(data?: ICreateRepoTradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundId = _data["fundId"];
            this.counterpartyId = _data["counterpartyId"];
            this.securityId = _data["securityId"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.direction = _data["direction"];
            this.notional = _data["notional"];
            this.rate = _data["rate"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : undefined as any;
            this.settlementDate = _data["settlementDate"] ? new Date(_data["settlementDate"].toString()) : undefined as any;
            this.currency = _data["currency"];
            this.haircut = _data["haircut"];
            this.createdByUserId = _data["createdByUserId"];
        }
    }

    static fromJS(data: any): CreateRepoTradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRepoTradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundId"] = this.fundId;
        data["counterpartyId"] = this.counterpartyId;
        data["securityId"] = this.securityId;
        data["collateralTypeId"] = this.collateralTypeId;
        data["direction"] = this.direction;
        data["notional"] = this.notional;
        data["rate"] = this.rate;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : undefined as any;
        data["settlementDate"] = this.settlementDate ? this.settlementDate.toISOString() : undefined as any;
        data["currency"] = this.currency;
        data["haircut"] = this.haircut;
        data["createdByUserId"] = this.createdByUserId;
        return data;
    }
}

export interface ICreateRepoTradeDto {
    fundId?: number;
    counterpartyId?: number;
    securityId?: number;
    collateralTypeId?: number;
    direction?: string | undefined;
    notional?: number;
    rate?: number;
    startDate?: Date;
    endDate?: Date;
    settlementDate?: Date;
    currency?: string | undefined;
    haircut?: number | undefined;
    createdByUserId?: number;
}

export class EagleCashBalanceDto implements IEagleCashBalanceDto {
    fundCode?: string | undefined;
    fundName?: string | undefined;
    openingBalance?: number;
    currency?: string | undefined;
    balanceDate?: Date;
    source?: string | undefined;

    constructor(data?: IEagleCashBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.openingBalance = _data["openingBalance"];
            this.currency = _data["currency"];
            this.balanceDate = _data["balanceDate"] ? new Date(_data["balanceDate"].toString()) : undefined as any;
            this.source = _data["source"];
        }
    }

    static fromJS(data: any): EagleCashBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new EagleCashBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["openingBalance"] = this.openingBalance;
        data["currency"] = this.currency;
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : undefined as any;
        data["source"] = this.source;
        return data;
    }
}

export interface IEagleCashBalanceDto {
    fundCode?: string | undefined;
    fundName?: string | undefined;
    openingBalance?: number;
    currency?: string | undefined;
    balanceDate?: Date;
    source?: string | undefined;
}

export class EagleExportRequestDto implements IEagleExportRequestDto {
    exportDate?: Date;
    exportedByUserId?: number;

    constructor(data?: IEagleExportRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exportDate = _data["exportDate"] ? new Date(_data["exportDate"].toString()) : undefined as any;
            this.exportedByUserId = _data["exportedByUserId"];
        }
    }

    static fromJS(data: any): EagleExportRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new EagleExportRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exportDate"] = this.exportDate ? this.exportDate.toISOString() : undefined as any;
        data["exportedByUserId"] = this.exportedByUserId;
        return data;
    }
}

export interface IEagleExportRequestDto {
    exportDate?: Date;
    exportedByUserId?: number;
}

export class EagleExportResponseDto implements IEagleExportResponseDto {
    success?: boolean;
    message?: string | undefined;
    fundBalances?: FundBalanceExportDto[] | undefined;
    exportDate?: Date;
    exportFilePath?: string | undefined;

    constructor(data?: IEagleExportResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            if (Array.isArray(_data["fundBalances"])) {
                this.fundBalances = [] as any;
                for (let item of _data["fundBalances"])
                    this.fundBalances!.push(FundBalanceExportDto.fromJS(item));
            }
            this.exportDate = _data["exportDate"] ? new Date(_data["exportDate"].toString()) : undefined as any;
            this.exportFilePath = _data["exportFilePath"];
        }
    }

    static fromJS(data: any): EagleExportResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EagleExportResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        if (Array.isArray(this.fundBalances)) {
            data["fundBalances"] = [];
            for (let item of this.fundBalances)
                data["fundBalances"].push(item ? item.toJSON() : undefined as any);
        }
        data["exportDate"] = this.exportDate ? this.exportDate.toISOString() : undefined as any;
        data["exportFilePath"] = this.exportFilePath;
        return data;
    }
}

export interface IEagleExportResponseDto {
    success?: boolean;
    message?: string | undefined;
    fundBalances?: FundBalanceExportDto[] | undefined;
    exportDate?: Date;
    exportFilePath?: string | undefined;
}

export class EagleImportRequestDto implements IEagleImportRequestDto {
    balanceDate?: Date;
    cashBalances?: EagleCashBalanceDto[] | undefined;
    importedByUserId?: number;

    constructor(data?: IEagleImportRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.balanceDate = _data["balanceDate"] ? new Date(_data["balanceDate"].toString()) : undefined as any;
            if (Array.isArray(_data["cashBalances"])) {
                this.cashBalances = [] as any;
                for (let item of _data["cashBalances"])
                    this.cashBalances!.push(EagleCashBalanceDto.fromJS(item));
            }
            this.importedByUserId = _data["importedByUserId"];
        }
    }

    static fromJS(data: any): EagleImportRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new EagleImportRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : undefined as any;
        if (Array.isArray(this.cashBalances)) {
            data["cashBalances"] = [];
            for (let item of this.cashBalances)
                data["cashBalances"].push(item ? item.toJSON() : undefined as any);
        }
        data["importedByUserId"] = this.importedByUserId;
        return data;
    }
}

export interface IEagleImportRequestDto {
    balanceDate?: Date;
    cashBalances?: EagleCashBalanceDto[] | undefined;
    importedByUserId?: number;
}

export class EagleImportResponseDto implements IEagleImportResponseDto {
    success?: boolean;
    message?: string | undefined;
    recordsProcessed?: number;
    recordsImported?: number;
    errors?: string[] | undefined;
    importDate?: Date;

    constructor(data?: IEagleImportResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.recordsProcessed = _data["recordsProcessed"];
            this.recordsImported = _data["recordsImported"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.importDate = _data["importDate"] ? new Date(_data["importDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): EagleImportResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EagleImportResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["recordsProcessed"] = this.recordsProcessed;
        data["recordsImported"] = this.recordsImported;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["importDate"] = this.importDate ? this.importDate.toISOString() : undefined as any;
        return data;
    }
}

export interface IEagleImportResponseDto {
    success?: boolean;
    message?: string | undefined;
    recordsProcessed?: number;
    recordsImported?: number;
    errors?: string[] | undefined;
    importDate?: Date;
}

export class FundBalanceDto implements IFundBalanceDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    availableCash?: number;
    openingBalance?: number | undefined;
    asOfDate?: Date;

    constructor(data?: IFundBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.currencyCode = _data["currencyCode"];
            this.availableCash = _data["availableCash"];
            this.openingBalance = _data["openingBalance"];
            this.asOfDate = _data["asOfDate"] ? new Date(_data["asOfDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): FundBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new FundBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["currencyCode"] = this.currencyCode;
        data["availableCash"] = this.availableCash;
        data["openingBalance"] = this.openingBalance;
        data["asOfDate"] = this.asOfDate ? this.asOfDate.toISOString() : undefined as any;
        return data;
    }
}

export interface IFundBalanceDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    availableCash?: number;
    openingBalance?: number | undefined;
    asOfDate?: Date;
}

export class FundBalanceExportDto implements IFundBalanceExportDto {
    fundCode?: string | undefined;
    fundName?: string | undefined;
    closingBalance?: number;
    currency?: string | undefined;
    balanceDate?: Date;
    isFlat?: boolean;

    constructor(data?: IFundBalanceExportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.closingBalance = _data["closingBalance"];
            this.currency = _data["currency"];
            this.balanceDate = _data["balanceDate"] ? new Date(_data["balanceDate"].toString()) : undefined as any;
            this.isFlat = _data["isFlat"];
        }
    }

    static fromJS(data: any): FundBalanceExportDto {
        data = typeof data === 'object' ? data : {};
        let result = new FundBalanceExportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["closingBalance"] = this.closingBalance;
        data["currency"] = this.currency;
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : undefined as any;
        data["isFlat"] = this.isFlat;
        return data;
    }
}

export interface IFundBalanceExportDto {
    fundCode?: string | undefined;
    fundName?: string | undefined;
    closingBalance?: number;
    currency?: string | undefined;
    balanceDate?: Date;
    isFlat?: boolean;
}

export class FundCashflowSummaryDto implements IFundCashflowSummaryDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    totalInflows?: number;
    totalOutflows?: number;
    netCashflow?: number;
    dateFrom?: Date;
    dateTo?: Date;

    constructor(data?: IFundCashflowSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.currencyCode = _data["currencyCode"];
            this.totalInflows = _data["totalInflows"];
            this.totalOutflows = _data["totalOutflows"];
            this.netCashflow = _data["netCashflow"];
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : undefined as any;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): FundCashflowSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new FundCashflowSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["currencyCode"] = this.currencyCode;
        data["totalInflows"] = this.totalInflows;
        data["totalOutflows"] = this.totalOutflows;
        data["netCashflow"] = this.netCashflow;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : undefined as any;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : undefined as any;
        return data;
    }
}

export interface IFundCashflowSummaryDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    totalInflows?: number;
    totalOutflows?: number;
    netCashflow?: number;
    dateFrom?: Date;
    dateTo?: Date;
}

export class FundDto implements IFundDto {
    id?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: IFundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.currencyCode = _data["currencyCode"];
            this.isActive = _data["isActive"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): FundDto {
        data = typeof data === 'object' ? data : {};
        let result = new FundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["currencyCode"] = this.currencyCode;
        data["isActive"] = this.isActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface IFundDto {
    id?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currencyCode?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class FundFlatnessCheckDto implements IFundFlatnessCheckDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currentBalance?: number;
    currency?: string | undefined;
    isFlat?: boolean;
    requiredAdjustment?: number;
    adjustmentType?: string | undefined;

    constructor(data?: IFundFlatnessCheckDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.currentBalance = _data["currentBalance"];
            this.currency = _data["currency"];
            this.isFlat = _data["isFlat"];
            this.requiredAdjustment = _data["requiredAdjustment"];
            this.adjustmentType = _data["adjustmentType"];
        }
    }

    static fromJS(data: any): FundFlatnessCheckDto {
        data = typeof data === 'object' ? data : {};
        let result = new FundFlatnessCheckDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["currentBalance"] = this.currentBalance;
        data["currency"] = this.currency;
        data["isFlat"] = this.isFlat;
        data["requiredAdjustment"] = this.requiredAdjustment;
        data["adjustmentType"] = this.adjustmentType;
        return data;
    }
}

export interface IFundFlatnessCheckDto {
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    currentBalance?: number;
    currency?: string | undefined;
    isFlat?: boolean;
    requiredAdjustment?: number;
    adjustmentType?: string | undefined;
}

export class PreviousDayRepoRateDto implements IPreviousDayRepoRateDto {
    id?: number;
    counterpartyId?: number;
    collateralTypeId?: number;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number;
    active?: boolean;

    constructor(data?: IPreviousDayRepoRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.counterpartyId = _data["counterpartyId"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.repoDate = _data["repoDate"] ? new Date(_data["repoDate"].toString()) : undefined as any;
            this.repoRate = _data["repoRate"];
            this.targetCircle = _data["targetCircle"];
            this.finalCircle = _data["finalCircle"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): PreviousDayRepoRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PreviousDayRepoRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["counterpartyId"] = this.counterpartyId;
        data["collateralTypeId"] = this.collateralTypeId;
        data["repoDate"] = this.repoDate ? this.repoDate.toISOString() : undefined as any;
        data["repoRate"] = this.repoRate;
        data["targetCircle"] = this.targetCircle;
        data["finalCircle"] = this.finalCircle;
        data["active"] = this.active;
        return data;
    }
}

export interface IPreviousDayRepoRateDto {
    id?: number;
    counterpartyId?: number;
    collateralTypeId?: number;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number;
    active?: boolean;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class RepoRateDto implements IRepoRateDto {
    id?: number;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: IRepoRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.counterpartyId = _data["counterpartyId"];
            this.counterpartyName = _data["counterpartyName"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.collateralTypeName = _data["collateralTypeName"];
            this.repoDate = _data["repoDate"] ? new Date(_data["repoDate"].toString()) : undefined as any;
            this.repoRate = _data["repoRate"];
            this.targetCircle = _data["targetCircle"];
            this.finalCircle = _data["finalCircle"];
            this.active = _data["active"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): RepoRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepoRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["counterpartyId"] = this.counterpartyId;
        data["counterpartyName"] = this.counterpartyName;
        data["collateralTypeId"] = this.collateralTypeId;
        data["collateralTypeName"] = this.collateralTypeName;
        data["repoDate"] = this.repoDate ? this.repoDate.toISOString() : undefined as any;
        data["repoRate"] = this.repoRate;
        data["targetCircle"] = this.targetCircle;
        data["finalCircle"] = this.finalCircle;
        data["active"] = this.active;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface IRepoRateDto {
    id?: number;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    repoDate?: Date;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class RepoTradeDto implements IRepoTradeDto {
    id?: number;
    tradeReference?: string | undefined;
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    securityId?: number;
    securityIsin?: string | undefined;
    securityName?: string | undefined;
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    direction?: string | undefined;
    notional?: number;
    rate?: number;
    startDate?: Date;
    endDate?: Date;
    settlementDate?: Date;
    status?: string | undefined;
    currency?: string | undefined;
    haircut?: number | undefined;
    collateralValue?: number | undefined;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: IRepoTradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tradeReference = _data["tradeReference"];
            this.fundId = _data["fundId"];
            this.fundCode = _data["fundCode"];
            this.fundName = _data["fundName"];
            this.counterpartyId = _data["counterpartyId"];
            this.counterpartyName = _data["counterpartyName"];
            this.securityId = _data["securityId"];
            this.securityIsin = _data["securityIsin"];
            this.securityName = _data["securityName"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.collateralTypeName = _data["collateralTypeName"];
            this.direction = _data["direction"];
            this.notional = _data["notional"];
            this.rate = _data["rate"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : undefined as any;
            this.settlementDate = _data["settlementDate"] ? new Date(_data["settlementDate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.currency = _data["currency"];
            this.haircut = _data["haircut"];
            this.collateralValue = _data["collateralValue"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : undefined as any;
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): RepoTradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepoTradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tradeReference"] = this.tradeReference;
        data["fundId"] = this.fundId;
        data["fundCode"] = this.fundCode;
        data["fundName"] = this.fundName;
        data["counterpartyId"] = this.counterpartyId;
        data["counterpartyName"] = this.counterpartyName;
        data["securityId"] = this.securityId;
        data["securityIsin"] = this.securityIsin;
        data["securityName"] = this.securityName;
        data["collateralTypeId"] = this.collateralTypeId;
        data["collateralTypeName"] = this.collateralTypeName;
        data["direction"] = this.direction;
        data["notional"] = this.notional;
        data["rate"] = this.rate;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : undefined as any;
        data["settlementDate"] = this.settlementDate ? this.settlementDate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["currency"] = this.currency;
        data["haircut"] = this.haircut;
        data["collateralValue"] = this.collateralValue;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : undefined as any;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface IRepoTradeDto {
    id?: number;
    tradeReference?: string | undefined;
    fundId?: number;
    fundCode?: string | undefined;
    fundName?: string | undefined;
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    securityId?: number;
    securityIsin?: string | undefined;
    securityName?: string | undefined;
    collateralTypeId?: number;
    collateralTypeName?: string | undefined;
    direction?: string | undefined;
    notional?: number;
    rate?: number;
    startDate?: Date;
    endDate?: Date;
    settlementDate?: Date;
    status?: string | undefined;
    currency?: string | undefined;
    haircut?: number | undefined;
    collateralValue?: number | undefined;
    createdDate?: Date;
    createdBy?: string | undefined;
    modifiedDate?: Date | undefined;
    modifiedBy?: string | undefined;
}

export class TargetCircleValidationDto implements ITargetCircleValidationDto {
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    tradeDate?: Date;
    currentExposure?: number;
    proposedNotional?: number;
    targetCircle?: number;
    newTotalExposure?: number;
    isWithinLimit?: boolean;
    limitUtilizationPercentage?: number;
    validationMessage?: string | undefined;

    constructor(data?: ITargetCircleValidationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.counterpartyId = _data["counterpartyId"];
            this.counterpartyName = _data["counterpartyName"];
            this.tradeDate = _data["tradeDate"] ? new Date(_data["tradeDate"].toString()) : undefined as any;
            this.currentExposure = _data["currentExposure"];
            this.proposedNotional = _data["proposedNotional"];
            this.targetCircle = _data["targetCircle"];
            this.newTotalExposure = _data["newTotalExposure"];
            this.isWithinLimit = _data["isWithinLimit"];
            this.limitUtilizationPercentage = _data["limitUtilizationPercentage"];
            this.validationMessage = _data["validationMessage"];
        }
    }

    static fromJS(data: any): TargetCircleValidationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TargetCircleValidationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counterpartyId"] = this.counterpartyId;
        data["counterpartyName"] = this.counterpartyName;
        data["tradeDate"] = this.tradeDate ? this.tradeDate.toISOString() : undefined as any;
        data["currentExposure"] = this.currentExposure;
        data["proposedNotional"] = this.proposedNotional;
        data["targetCircle"] = this.targetCircle;
        data["newTotalExposure"] = this.newTotalExposure;
        data["isWithinLimit"] = this.isWithinLimit;
        data["limitUtilizationPercentage"] = this.limitUtilizationPercentage;
        data["validationMessage"] = this.validationMessage;
        return data;
    }
}

export interface ITargetCircleValidationDto {
    counterpartyId?: number;
    counterpartyName?: string | undefined;
    tradeDate?: Date;
    currentExposure?: number;
    proposedNotional?: number;
    targetCircle?: number;
    newTotalExposure?: number;
    isWithinLimit?: boolean;
    limitUtilizationPercentage?: number;
    validationMessage?: string | undefined;
}

export class UpdateCounterpartyDto implements IUpdateCounterpartyDto {
    id?: number;
    shortName?: string | undefined;
    country?: string | undefined;
    creditRating?: string | undefined;
    sector?: string | undefined;
    isActive?: boolean;
    modifiedByUserId?: number;

    constructor(data?: IUpdateCounterpartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.shortName = _data["shortName"];
            this.country = _data["country"];
            this.creditRating = _data["creditRating"];
            this.sector = _data["sector"];
            this.isActive = _data["isActive"];
            this.modifiedByUserId = _data["modifiedByUserId"];
        }
    }

    static fromJS(data: any): UpdateCounterpartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCounterpartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["shortName"] = this.shortName;
        data["country"] = this.country;
        data["creditRating"] = this.creditRating;
        data["sector"] = this.sector;
        data["isActive"] = this.isActive;
        data["modifiedByUserId"] = this.modifiedByUserId;
        return data;
    }
}

export interface IUpdateCounterpartyDto {
    id?: number;
    shortName?: string | undefined;
    country?: string | undefined;
    creditRating?: string | undefined;
    sector?: string | undefined;
    isActive?: boolean;
    modifiedByUserId?: number;
}

export class UpdateFundDto implements IUpdateFundDto {
    id?: number;
    fundName?: string | undefined;
    isActive?: boolean;
    modifiedByUserId?: number;

    constructor(data?: IUpdateFundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fundName = _data["fundName"];
            this.isActive = _data["isActive"];
            this.modifiedByUserId = _data["modifiedByUserId"];
        }
    }

    static fromJS(data: any): UpdateFundDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fundName"] = this.fundName;
        data["isActive"] = this.isActive;
        data["modifiedByUserId"] = this.modifiedByUserId;
        return data;
    }
}

export interface IUpdateFundDto {
    id?: number;
    fundName?: string | undefined;
    isActive?: boolean;
    modifiedByUserId?: number;
}

export class UpdateRepoRateDto implements IUpdateRepoRateDto {
    id?: number;
    counterpartyId?: number;
    collateralTypeId?: number;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean | undefined;
    modifiedByUserId?: number;

    constructor(data?: IUpdateRepoRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.counterpartyId = _data["counterpartyId"];
            this.collateralTypeId = _data["collateralTypeId"];
            this.repoRate = _data["repoRate"];
            this.targetCircle = _data["targetCircle"];
            this.finalCircle = _data["finalCircle"];
            this.active = _data["active"];
            this.modifiedByUserId = _data["modifiedByUserId"];
        }
    }

    static fromJS(data: any): UpdateRepoRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRepoRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["counterpartyId"] = this.counterpartyId;
        data["collateralTypeId"] = this.collateralTypeId;
        data["repoRate"] = this.repoRate;
        data["targetCircle"] = this.targetCircle;
        data["finalCircle"] = this.finalCircle;
        data["active"] = this.active;
        data["modifiedByUserId"] = this.modifiedByUserId;
        return data;
    }
}

export interface IUpdateRepoRateDto {
    id?: number;
    counterpartyId?: number;
    collateralTypeId?: number;
    repoRate?: number;
    targetCircle?: number;
    finalCircle?: number | undefined;
    active?: boolean | undefined;
    modifiedByUserId?: number;
}

export class UpdateRepoTradeDto implements IUpdateRepoTradeDto {
    id?: number;
    notional?: number;
    rate?: number;
    startDate?: Date;
    endDate?: Date;
    settlementDate?: Date;
    haircut?: number | undefined;
    modifiedByUserId?: number;

    constructor(data?: IUpdateRepoTradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.notional = _data["notional"];
            this.rate = _data["rate"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : undefined as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : undefined as any;
            this.settlementDate = _data["settlementDate"] ? new Date(_data["settlementDate"].toString()) : undefined as any;
            this.haircut = _data["haircut"];
            this.modifiedByUserId = _data["modifiedByUserId"];
        }
    }

    static fromJS(data: any): UpdateRepoTradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRepoTradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["notional"] = this.notional;
        data["rate"] = this.rate;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : undefined as any;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : undefined as any;
        data["settlementDate"] = this.settlementDate ? this.settlementDate.toISOString() : undefined as any;
        data["haircut"] = this.haircut;
        data["modifiedByUserId"] = this.modifiedByUserId;
        return data;
    }
}

export interface IUpdateRepoTradeDto {
    id?: number;
    notional?: number;
    rate?: number;
    startDate?: Date;
    endDate?: Date;
    settlementDate?: Date;
    haircut?: number | undefined;
    modifiedByUserId?: number;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    readonly temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : undefined as any;
            this.temperatureC = _data["temperatureC"];
            (this as any).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? formatDate(this.date) : undefined as any;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}